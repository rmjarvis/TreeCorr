

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>treecorr.binnedcorr2 &mdash; TreeCorr 4.2.3 documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> TreeCorr
          

          
          </a>

          
            
            
              <div class="version">
                4.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../catalog.html">Input Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../correlation2.html">Two-point Correlation Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../correlation3.html">Three-point Correlation Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../metric.html">Metrics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../binning.html">Binning</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../patches.html">Patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cov.html">Covariance Estimates</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../field.html">Fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../scripts.html">Using configuration files</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../guide.html">Getting Started Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../changes.html">Changes from version 4.1 to 4.2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../changes.html#changes-from-version-4-2-0-to-4-2-1">Changes from version 4.2.0 to 4.2.1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../changes.html#changes-from-version-4-2-1-to-4-2-2">Changes from version 4.2.1 to 4.2.2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../changes.html#changes-from-version-4-2-2-to-4-2-3">Changes from version 4.2.2 to 4.2.3</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../history.html">Previous History</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">TreeCorr</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>treecorr.binnedcorr2</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for treecorr.binnedcorr2</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (c) 2003-2019 by Mike Jarvis</span>
<span class="c1">#</span>
<span class="c1"># TreeCorr is free software: redistribution and use in source and binary forms,</span>
<span class="c1"># with or without modification, are permitted provided that the following</span>
<span class="c1"># conditions are met:</span>
<span class="c1">#</span>
<span class="c1"># 1. Redistributions of source code must retain the above copyright notice, this</span>
<span class="c1">#    list of conditions, and the disclaimer given in the accompanying LICENSE</span>
<span class="c1">#    file.</span>
<span class="c1"># 2. Redistributions in binary form must reproduce the above copyright notice,</span>
<span class="c1">#    this list of conditions, and the disclaimer given in the documentation</span>
<span class="c1">#    and/or other materials provided with the distribution.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">.. module:: binnedcorr2</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">coord</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">_lib</span>
<span class="kn">from</span> <span class="nn">.config</span> <span class="kn">import</span> <span class="n">merge_config</span><span class="p">,</span> <span class="n">setup_logger</span><span class="p">,</span> <span class="n">get</span>
<span class="kn">from</span> <span class="nn">.util</span> <span class="kn">import</span> <span class="n">parse_metric</span><span class="p">,</span> <span class="n">metric_enum</span><span class="p">,</span> <span class="n">coord_enum</span><span class="p">,</span> <span class="n">set_omp_threads</span><span class="p">,</span> <span class="n">lazy_property</span>

<span class="k">class</span> <span class="nc">Namespace</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">pass</span>

<div class="viewcode-block" id="BinnedCorr2"><a class="viewcode-back" href="../../correlation2.html#treecorr.BinnedCorr2">[docs]</a><span class="k">class</span> <span class="nc">BinnedCorr2</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This class stores the results of a 2-point correlation calculation, along with some</span>
<span class="sd">    ancillary data.</span>

<span class="sd">    This is a base class that is not intended to be constructed directly.  But it has a few</span>
<span class="sd">    helper functions that derived classes can use to help perform their calculations.  See</span>
<span class="sd">    the derived classes for more details:</span>

<span class="sd">    - `GGCorrelation` handles shear-shear correlation functions</span>
<span class="sd">    - `NNCorrelation` handles count-count correlation functions</span>
<span class="sd">    - `KKCorrelation` handles kappa-kappa correlation functions</span>
<span class="sd">    - `NGCorrelation` handles count-shear correlation functions</span>
<span class="sd">    - `NKCorrelation` handles count-kappa correlation functions</span>
<span class="sd">    - `KGCorrelation` handles kappa-shear correlation functions</span>

<span class="sd">    .. note::</span>

<span class="sd">        When we refer to kappa in the correlation functions, that is because TreeCorr was</span>
<span class="sd">        originally designed for weak lensing applications.  But in fact any scalar quantity</span>
<span class="sd">        may be used here.  CMB temperature fluctuations for example.</span>

<span class="sd">    The constructor for all derived classes take a config dict as the first argument,</span>
<span class="sd">    since this is often how we keep track of parameters, but if you don&#39;t want to</span>
<span class="sd">    use one or if you want to change some parameters from what are in a config dict,</span>
<span class="sd">    then you can use normal kwargs, which take precedence over anything in the config dict.</span>

<span class="sd">    There are a number of possible definitions for the distance between two points, which</span>
<span class="sd">    are appropriate for different use cases.  These are specified by the ``metric`` parameter.</span>
<span class="sd">    The possible options are:</span>

<span class="sd">        - &#39;Euclidean&#39; = straight line Euclidean distance between two points.</span>
<span class="sd">        - &#39;FisherRperp&#39; = the perpendicular component of the distance, following the</span>
<span class="sd">          definitions in Fisher et al, 1994 (MNRAS, 267, 927).</span>
<span class="sd">        - &#39;OldRperp&#39; = the perpendicular component of the distance using the definition</span>
<span class="sd">          of Rperp from TreeCorr v3.x.</span>
<span class="sd">        - &#39;Rperp&#39; = an alias for FisherRperp.  You can change it to be an alias for</span>
<span class="sd">          OldRperp if you want by setting ``treecorr.Rperp_alias = &#39;OldRperp&#39;`` before</span>
<span class="sd">          using it.</span>
<span class="sd">        - &#39;Rlens&#39; = the distance from the first object (taken to be a lens) to the line</span>
<span class="sd">          connecting Earth and the second object (taken to be a lensed source).</span>
<span class="sd">        - &#39;Arc&#39; = the true great circle distance for spherical coordinates.</span>
<span class="sd">        - &#39;Periodic&#39; = Like Euclidean, but with periodic boundaries.</span>

<span class="sd">    See `Metrics` for more information about these various metric options.</span>

<span class="sd">    There are also a few different possibile binning prescriptions to define the range of</span>
<span class="sd">    distances, which should be placed into each bin.</span>

<span class="sd">        - &#39;Log&#39; - logarithmic binning in the distance.  The bin steps will be uniform in</span>
<span class="sd">          log(r) from log(min_sep) .. log(max_sep).</span>
<span class="sd">        - &#39;Linear&#39; - linear binning in the distance.  The bin steps will be uniform in r</span>
<span class="sd">          from min_sep .. max_sep.</span>
<span class="sd">        - &#39;TwoD&#39; = 2-dimensional binning from x = (-max_sep .. max_sep) and</span>
<span class="sd">          y = (-max_sep .. max_sep).  The bin steps will be uniform in both x and y.</span>
<span class="sd">          (i.e. linear in x,y)</span>

<span class="sd">    See `Binning` for more information about the different binning options.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        config (dict):      A configuration dict that can be used to pass in the below kwargs if</span>
<span class="sd">                            desired.  This dict is allowed to have addition entries in addition</span>
<span class="sd">                            to those listed below, which are ignored here. (default: None)</span>
<span class="sd">        logger:             If desired, a logger object for logging. (default: None, in which case</span>
<span class="sd">                            one will be built according to the config dict&#39;s verbose level.)</span>

<span class="sd">    Keyword Arguments:</span>

<span class="sd">        nbins (int):        How many bins to use. (Exactly three of nbins, bin_size, min_sep,</span>
<span class="sd">                            max_sep are required. If nbins is not given, it will be calculated from</span>
<span class="sd">                            the values of the other three, rounding up to the next highest integer.</span>
<span class="sd">                            In this case, bin_size will be readjusted to account for this rounding</span>
<span class="sd">                            up.)</span>
<span class="sd">        bin_size (float):   The width of the bins in log(separation). (Exactly three of nbins,</span>
<span class="sd">                            bin_size, min_sep, max_sep are required.  If bin_size is not given, it</span>
<span class="sd">                            will be calculated from the values of the other three.)</span>
<span class="sd">        min_sep (float):    The minimum separation in units of sep_units, if relevant. (Exactly</span>
<span class="sd">                            three of nbins, bin_size, min_sep, max_sep are required.  If min_sep is</span>
<span class="sd">                            not given, it will be calculated from the values of the other three.)</span>
<span class="sd">        max_sep (float):    The maximum separation in units of sep_units, if relevant. (Exactly</span>
<span class="sd">                            three of nbins, bin_size, min_sep, max_sep are required.  If max_sep is</span>
<span class="sd">                            not given, it will be calculated from the values of the other three.</span>

<span class="sd">        sep_units (str):    The units to use for the separation values, given as a string.  This</span>
<span class="sd">                            includes both min_sep and max_sep above, as well as the units of the</span>
<span class="sd">                            output distance values.  Valid options are arcsec, arcmin, degrees,</span>
<span class="sd">                            hours, radians.  (default: radians if angular units make sense, but for</span>
<span class="sd">                            3-d or flat 2-d positions, the default will just match the units of</span>
<span class="sd">                            x,y[,z] coordinates)</span>
<span class="sd">        bin_slop (float):   How much slop to allow in the placement of pairs in the bins.</span>
<span class="sd">                            If bin_slop = 1, then the bin into which a particular pair is placed</span>
<span class="sd">                            may be incorrect by at most 1.0 bin widths.  (default: None, which</span>
<span class="sd">                            means to use a bin_slop that gives a maximum error of 10% on any bin,</span>
<span class="sd">                            which has been found to yield good results for most application.</span>
<span class="sd">        brute (bool):       Whether to use the &quot;brute force&quot; algorithm.  (default: False) Options</span>
<span class="sd">                            are:</span>

<span class="sd">                             - False (the default): Stop at non-leaf cells whenever the error in</span>
<span class="sd">                               the separation is compatible with the given bin_slop.</span>
<span class="sd">                             - True: Go to the leaves for both catalogs.</span>
<span class="sd">                             - 1: Always go to the leaves for cat1, but stop at non-leaf cells of</span>
<span class="sd">                               cat2 when the error is compatible with the given bin_slop.</span>
<span class="sd">                             - 2: Always go to the leaves for cat2, but stop at non-leaf cells of</span>
<span class="sd">                               cat1 when the error is compatible with the given bin_slop.</span>

<span class="sd">        verbose (int):      If no logger is provided, this will optionally specify a logging level</span>
<span class="sd">                            to use:</span>

<span class="sd">                             - 0 means no logging output</span>
<span class="sd">                             - 1 means to output warnings only (default)</span>
<span class="sd">                             - 2 means to output various progress information</span>
<span class="sd">                             - 3 means to output extensive debugging information</span>

<span class="sd">        log_file (str):     If no logger is provided, this will specify a file to write the logging</span>
<span class="sd">                            output.  (default: None; i.e. output to standard output)</span>
<span class="sd">        output_dots (bool): Whether to output progress dots during the calcualtion of the</span>
<span class="sd">                            correlation function. (default: False unless verbose is given and &gt;= 2,</span>
<span class="sd">                            in which case True)</span>

<span class="sd">        split_method (str): How to split the cells in the tree when building the tree structure.</span>
<span class="sd">                            Options are:</span>

<span class="sd">                            - mean = Use the arithmetic mean of the coordinate being split.</span>
<span class="sd">                              (default)</span>
<span class="sd">                            - median = Use the median of the coordinate being split.</span>
<span class="sd">                            - middle = Use the middle of the range; i.e. the average of the minimum</span>
<span class="sd">                              and maximum value.</span>
<span class="sd">                            - random: Use a random point somewhere in the middle two quartiles of</span>
<span class="sd">                              the range.</span>

<span class="sd">        min_top (int):      The minimum number of top layers to use when setting up the field.</span>
<span class="sd">                            (default: :math:`\\max(3, \\log_2(N_{\\rm cpu}))`)</span>
<span class="sd">        max_top (int):      The maximum number of top layers to use when setting up the field.</span>
<span class="sd">                            The top-level cells are where each calculation job starts. There will</span>
<span class="sd">                            typically be of order :math:`2^{\\rm max\\_top}` top-level cells.</span>
<span class="sd">                            (default: 10)</span>
<span class="sd">        precision (int):    The precision to use for the output values. This specifies how many</span>
<span class="sd">                            digits to write. (default: 4)</span>
<span class="sd">        pairwise (bool):    Whether to use a different kind of calculation for cross correlations</span>
<span class="sd">                            whereby corresponding items in the two catalogs are correlated pairwise</span>
<span class="sd">                            rather than the usual case of every item in one catalog being correlated</span>
<span class="sd">                            with every item in the other catalog. (default: False) (DEPRECATED)</span>
<span class="sd">        m2_uform (str):     The default functional form to use for aperture mass calculations.</span>
<span class="sd">                            see `calculateMapSq` for more details.  (default: &#39;Crittenden&#39;)</span>

<span class="sd">        metric (str):       Which metric to use for distance measurements.  Options are listed</span>
<span class="sd">                            above.  (default: &#39;Euclidean&#39;)</span>
<span class="sd">        bin_type (str):     What type of binning should be used.  Options are listed above.</span>
<span class="sd">                            (default: &#39;Log&#39;)</span>
<span class="sd">        min_rpar (float):   The minimum difference in Rparallel to allow for pairs being included</span>
<span class="sd">                            in the correlation function.  (default: None)</span>
<span class="sd">        max_rpar (float):   The maximum difference in Rparallel to allow for pairs being included</span>
<span class="sd">                            in the correlation function.  (default: None)</span>
<span class="sd">        period (float):     For the &#39;Periodic&#39; metric, the period to use in all directions.</span>
<span class="sd">                            (default: None)</span>
<span class="sd">        xperiod (float):    For the &#39;Periodic&#39; metric, the period to use in the x direction.</span>
<span class="sd">                            (default: period)</span>
<span class="sd">        yperiod (float):    For the &#39;Periodic&#39; metric, the period to use in the y direction.</span>
<span class="sd">                            (default: period)</span>
<span class="sd">        zperiod (float):    For the &#39;Periodic&#39; metric, the period to use in the z direction.</span>
<span class="sd">                            (default: period)</span>

<span class="sd">        var_method (str):   Which method to use for estimating the variance. Options are:</span>
<span class="sd">                            &#39;shot&#39;, &#39;jackknife&#39;, &#39;sample&#39;, &#39;bootstrap&#39;, &#39;marked_bootstrap&#39;.</span>
<span class="sd">                            (default: &#39;shot&#39;)</span>
<span class="sd">        num_bootstrap (int): How many bootstrap samples to use for the &#39;bootstrap&#39; and</span>
<span class="sd">                            &#39;marked_bootstrap&#39; var_methods.  (default: 500)</span>
<span class="sd">        rng (RandomState):  If desired, a numpy.random.RandomState instance to use for bootstrap</span>
<span class="sd">                            random number generation. (default: None)</span>

<span class="sd">        num_threads (int):  How many OpenMP threads to use during the calculation.</span>
<span class="sd">                            (default: use the number of cpu cores)</span>

<span class="sd">                            .. note::</span>

<span class="sd">                                This won&#39;t work if the system&#39;s C compiler cannot use OpenMP</span>
<span class="sd">                                (e.g. clang prior to version 3.7.)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_valid_params</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;nbins&#39;</span> <span class="p">:</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;The number of output bins to use.&#39;</span><span class="p">),</span>
        <span class="s1">&#39;bin_size&#39;</span> <span class="p">:</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;The size of the output bins in log(sep).&#39;</span><span class="p">),</span>
        <span class="s1">&#39;min_sep&#39;</span> <span class="p">:</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;The minimum separation to include in the output.&#39;</span><span class="p">),</span>
        <span class="s1">&#39;max_sep&#39;</span> <span class="p">:</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;The maximum separation to include in the output.&#39;</span><span class="p">),</span>
        <span class="s1">&#39;sep_units&#39;</span> <span class="p">:</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">coord</span><span class="o">.</span><span class="n">AngleUnit</span><span class="o">.</span><span class="n">valid_names</span><span class="p">,</span>
                <span class="s1">&#39;The units to use for min_sep and max_sep.  &#39;</span>
                <span class="s1">&#39;Also the units of the output distances&#39;</span><span class="p">),</span>
        <span class="s1">&#39;bin_slop&#39;</span> <span class="p">:</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;The fraction of a bin width by which it is ok to let the pairs miss the correct &#39;</span>
                <span class="s1">&#39;bin.&#39;</span><span class="p">,</span>
                <span class="s1">&#39;The default is to use 1 if bin_size &lt;= 0.1, or 0.1/bin_size if bin_size &gt; 0.1.&#39;</span><span class="p">),</span>
        <span class="s1">&#39;brute&#39;</span> <span class="p">:</span> <span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
                <span class="s1">&#39;Whether to use brute-force algorithm&#39;</span><span class="p">),</span>
        <span class="s1">&#39;verbose&#39;</span> <span class="p">:</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
                <span class="s1">&#39;How verbose the code should be during processing. &#39;</span><span class="p">,</span>
                <span class="s1">&#39;0 = Errors Only, 1 = Warnings, 2 = Progress, 3 = Debugging&#39;</span><span class="p">),</span>
        <span class="s1">&#39;log_file&#39;</span> <span class="p">:</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;If desired, an output file for the logging output.&#39;</span><span class="p">,</span>
                <span class="s1">&#39;The default is to write the output to stdout.&#39;</span><span class="p">),</span>
        <span class="s1">&#39;output_dots&#39;</span> <span class="p">:</span> <span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;Whether to output dots to the stdout during the C++-level computation.&#39;</span><span class="p">,</span>
                <span class="s1">&#39;The default is True if verbose &gt;= 2 and there is no log_file.  Else False.&#39;</span><span class="p">),</span>
        <span class="s1">&#39;split_method&#39;</span> <span class="p">:</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="s1">&#39;median&#39;</span><span class="p">,</span> <span class="s1">&#39;middle&#39;</span><span class="p">,</span> <span class="s1">&#39;random&#39;</span><span class="p">],</span>
                <span class="s1">&#39;Which method to use for splitting cells.&#39;</span><span class="p">),</span>
        <span class="s1">&#39;min_top&#39;</span> <span class="p">:</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;The minimum number of top layers to use when setting up the field.&#39;</span><span class="p">),</span>
        <span class="s1">&#39;max_top&#39;</span> <span class="p">:</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;The maximum number of top layers to use when setting up the field.&#39;</span><span class="p">),</span>
        <span class="s1">&#39;precision&#39;</span> <span class="p">:</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;The number of digits after the decimal in the output.&#39;</span><span class="p">),</span>
        <span class="s1">&#39;pairwise&#39;</span> <span class="p">:</span> <span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;Whether to do a pair-wise cross-correlation. (DEPRECATED)&#39;</span><span class="p">),</span>
        <span class="s1">&#39;m2_uform&#39;</span> <span class="p">:</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;Crittenden&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;Crittenden&#39;</span><span class="p">,</span> <span class="s1">&#39;Schneider&#39;</span><span class="p">],</span>
                <span class="s1">&#39;The function form of the mass aperture.&#39;</span><span class="p">),</span>
        <span class="s1">&#39;metric&#39;</span><span class="p">:</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;Euclidean&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;Euclidean&#39;</span><span class="p">,</span> <span class="s1">&#39;Rperp&#39;</span><span class="p">,</span> <span class="s1">&#39;FisherRperp&#39;</span><span class="p">,</span> <span class="s1">&#39;OldRperp&#39;</span><span class="p">,</span>
                                             <span class="s1">&#39;Rlens&#39;</span><span class="p">,</span> <span class="s1">&#39;Arc&#39;</span><span class="p">,</span> <span class="s1">&#39;Periodic&#39;</span><span class="p">],</span>
                <span class="s1">&#39;Which metric to use for the distance measurements&#39;</span><span class="p">),</span>
        <span class="s1">&#39;bin_type&#39;</span><span class="p">:</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;Log&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;Log&#39;</span><span class="p">,</span> <span class="s1">&#39;Linear&#39;</span><span class="p">,</span> <span class="s1">&#39;TwoD&#39;</span><span class="p">],</span>
                <span class="s1">&#39;Which type of binning should be used&#39;</span><span class="p">),</span>
        <span class="s1">&#39;min_rpar&#39;</span><span class="p">:</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;The minimum difference in Rparallel for pairs to include&#39;</span><span class="p">),</span>
        <span class="s1">&#39;max_rpar&#39;</span><span class="p">:</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;The maximum difference in Rparallel for pairs to include&#39;</span><span class="p">),</span>
        <span class="s1">&#39;period&#39;</span><span class="p">:</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;The period to use for all directions for the Periodic metric&#39;</span><span class="p">),</span>
        <span class="s1">&#39;xperiod&#39;</span><span class="p">:</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;The period to use for the x direction for the Periodic metric&#39;</span><span class="p">),</span>
        <span class="s1">&#39;yperiod&#39;</span><span class="p">:</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;The period to use for the y direction for the Periodic metric&#39;</span><span class="p">),</span>
        <span class="s1">&#39;zperiod&#39;</span><span class="p">:</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;The period to use for the z direction for the Periodic metric&#39;</span><span class="p">),</span>

        <span class="s1">&#39;var_method&#39;</span><span class="p">:</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;shot&#39;</span><span class="p">,</span>
                <span class="p">[</span><span class="s1">&#39;shot&#39;</span><span class="p">,</span> <span class="s1">&#39;jackknife&#39;</span><span class="p">,</span> <span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;bootstrap&#39;</span><span class="p">,</span> <span class="s1">&#39;marked_bootstrap&#39;</span><span class="p">],</span>
                <span class="s1">&#39;The method to use for estimating the variance&#39;</span><span class="p">),</span>
        <span class="s1">&#39;num_bootstrap&#39;</span><span class="p">:</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;How many bootstrap samples to use for the var_method=bootstrap and &#39;</span>
                <span class="s1">&#39;marked_bootstrap&#39;</span><span class="p">),</span>
        <span class="s1">&#39;num_threads&#39;</span> <span class="p">:</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;How many threads should be used. num_threads &lt;= 0 means auto based on num cores.&#39;</span><span class="p">),</span>
    <span class="p">}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">config</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_corr</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Do this first to make sure we always have it for __del__</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">config</span> <span class="o">=</span> <span class="n">merge_config</span><span class="p">(</span><span class="n">config</span><span class="p">,</span><span class="n">kwargs</span><span class="p">,</span><span class="n">BinnedCorr2</span><span class="o">.</span><span class="n">_valid_params</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">logger</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">setup_logger</span><span class="p">(</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">,</span><span class="s1">&#39;verbose&#39;</span><span class="p">,</span><span class="nb">int</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;log_file&#39;</span><span class="p">,</span><span class="kc">None</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logger</span>

        <span class="c1"># We&#39;ll make a bunch of attributes here, which we put into a namespace called _ro.</span>
        <span class="c1"># These are the core attributes that won&#39;t ever be changed after construction.</span>
        <span class="c1"># This is an efficiency optimization (both memory and flops), since it will allow</span>
        <span class="c1"># copy() to just copy a pointer to the _ro namespace without having to copy each</span>
        <span class="c1"># individual attribute separately.</span>
        <span class="c1"># The access of these attributes are all via read-only properties.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span> <span class="o">=</span> <span class="n">Namespace</span><span class="p">()</span>

        <span class="k">if</span> <span class="s1">&#39;output_dots&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">output_dots</span> <span class="o">=</span> <span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">,</span><span class="s1">&#39;output_dots&#39;</span><span class="p">,</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">output_dots</span> <span class="o">=</span> <span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">,</span><span class="s1">&#39;verbose&#39;</span><span class="p">,</span><span class="nb">int</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">bin_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;bin_type&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">sep_units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;sep_units&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">_sep_units</span> <span class="o">=</span> <span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">,</span><span class="s1">&#39;sep_units&#39;</span><span class="p">,</span><span class="nb">str</span><span class="p">,</span><span class="s1">&#39;radians&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">_log_sep_units</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sep_units</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;nbins&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;max_sep&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Missing required parameter max_sep&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">&#39;min_sep&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_type</span> <span class="o">!=</span> <span class="s1">&#39;TwoD&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Missing required parameter min_sep&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">&#39;bin_size&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Missing required parameter bin_size&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">min_sep</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;min_sep&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">max_sep</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;max_sep&#39;</span><span class="p">])</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_sep</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_sep</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;max_sep must be larger than min_sep&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">bin_size</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;bin_size&#39;</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">nbins</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="s1">&#39;bin_size&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;max_sep&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Missing required parameter max_sep&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">&#39;min_sep&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_type</span> <span class="o">!=</span> <span class="s1">&#39;TwoD&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Missing required parameter min_sep&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">min_sep</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;min_sep&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">max_sep</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;max_sep&#39;</span><span class="p">])</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_sep</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_sep</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;max_sep must be larger than min_sep&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">nbins</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;nbins&#39;</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">bin_size</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="s1">&#39;max_sep&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;min_sep&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_type</span> <span class="o">!=</span> <span class="s1">&#39;TwoD&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Missing required parameter min_sep&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">min_sep</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;min_sep&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">nbins</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;nbins&#39;</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">bin_size</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;bin_size&#39;</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">max_sep</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_type</span> <span class="o">==</span> <span class="s1">&#39;TwoD&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Only 2 of max_sep, bin_size, nbins are allowed &quot;</span>
                                <span class="s2">&quot;for bin_type=&#39;TwoD&#39;.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">&#39;min_sep&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Only 3 of min_sep, max_sep, bin_size, nbins are allowed.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">max_sep</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;max_sep&#39;</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">nbins</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;nbins&#39;</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">bin_size</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;bin_size&#39;</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">min_sep</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_type</span> <span class="o">==</span> <span class="s1">&#39;Log&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbins</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">nbins</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_sep</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">min_sep</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span><span class="p">))</span>
                <span class="c1"># Update bin_size given this value of nbins</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">bin_size</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_sep</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">min_sep</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">nbins</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">bin_size</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_sep</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">min_sep</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">nbins</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_sep</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">max_sep</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbins</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">min_sep</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">min_sep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_sep</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">nbins</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span><span class="p">)</span>

            <span class="c1"># This makes nbins evenly spaced entries in log(r) starting with 0 with step bin_size</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">logr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbins</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbins</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                          <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="c1"># Offset by the position of the center of the first bin.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">logr</span> <span class="o">+=</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_sep</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">rnom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logr</span><span class="p">)</span>
            <span class="n">half_bin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">left_edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rnom</span> <span class="o">/</span> <span class="n">half_bin</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">right_edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rnom</span> <span class="o">*</span> <span class="n">half_bin</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">_nbins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbins</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">_bintype</span> <span class="o">=</span> <span class="n">_lib</span><span class="o">.</span><span class="n">Log</span>
            <span class="n">min_log_bin_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span>
            <span class="n">max_log_bin_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span>
            <span class="n">max_good_slop</span> <span class="o">=</span> <span class="mf">0.1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_type</span> <span class="o">==</span> <span class="s1">&#39;Linear&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbins</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">nbins</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">max_sep</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">min_sep</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span><span class="p">))</span>
                <span class="c1"># Update bin_size given this value of nbins</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">bin_size</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_sep</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">min_sep</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">nbins</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">bin_size</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_sep</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">min_sep</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">nbins</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_sep</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">max_sep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_sep</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbins</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">min_sep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_sep</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbins</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">rnom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_sep</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_sep</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbins</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                          <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="c1"># Offset by the position of the center of the first bin.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">rnom</span> <span class="o">+=</span> <span class="mf">0.5</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">left_edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rnom</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">right_edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rnom</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">logr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rnom</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">_nbins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbins</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">_bintype</span> <span class="o">=</span> <span class="n">_lib</span><span class="o">.</span><span class="n">Linear</span>
            <span class="n">min_log_bin_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_sep</span>
            <span class="n">max_log_bin_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_sep</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">max_good_slop</span> <span class="o">=</span> <span class="mf">0.1</span> <span class="o">/</span> <span class="n">max_log_bin_size</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_type</span> <span class="o">==</span> <span class="s1">&#39;TwoD&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbins</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">nbins</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">max_sep</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">bin_size</span> <span class="o">=</span> <span class="mf">2.</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">max_sep</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">nbins</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">bin_size</span> <span class="o">=</span> <span class="mf">2.</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">max_sep</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">nbins</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">max_sep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbins</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span> <span class="o">/</span> <span class="mf">2.</span>

            <span class="n">sep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">max_sep</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_sep</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbins</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                              <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">sep</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span>
            <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="n">sep</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">left_edges</span> <span class="o">=</span> <span class="n">dx</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">right_edges</span> <span class="o">=</span> <span class="n">dx</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">bottom_edges</span> <span class="o">=</span> <span class="n">dy</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">top_edges</span> <span class="o">=</span> <span class="n">dy</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">rnom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">dy</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">logr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rnom</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rnom</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">logr</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rnom</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">logr</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">rnom</span><span class="o">==</span><span class="mf">0.</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">_nbins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbins</span><span class="o">**</span><span class="mi">2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">_bintype</span> <span class="o">=</span> <span class="n">_lib</span><span class="o">.</span><span class="n">TwoD</span>
            <span class="n">min_log_bin_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_sep</span>
            <span class="n">max_log_bin_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_sep</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">max_good_slop</span> <span class="o">=</span> <span class="mf">0.1</span> <span class="o">/</span> <span class="n">max_log_bin_size</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># pragma: no cover  (Already checked by config layer)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid bin_type </span><span class="si">%s</span><span class="s2">&quot;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_type</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sep_units</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;nbins = </span><span class="si">%d</span><span class="s2">, min,max sep = </span><span class="si">%g</span><span class="s2">..</span><span class="si">%g</span><span class="s2">, bin_size = </span><span class="si">%g</span><span class="s2">&quot;</span><span class="p">,</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">nbins</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_sep</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_sep</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;nbins = </span><span class="si">%d</span><span class="s2">, min,max sep = </span><span class="si">%g</span><span class="s2">..</span><span class="si">%g</span><span class="s2"> </span><span class="si">%s</span><span class="s2">, bin_size = </span><span class="si">%g</span><span class="s2">&quot;</span><span class="p">,</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">nbins</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_sep</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_sep</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sep_units</span><span class="p">,</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span><span class="p">)</span>
        <span class="c1"># The underscore-prefixed names are in natural units (radians for angles)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">_min_sep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_sep</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sep_units</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">_max_sep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_sep</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sep_units</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;Linear&#39;</span><span class="p">,</span> <span class="s1">&#39;TwoD&#39;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">_bin_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sep_units</span>
            <span class="n">min_log_bin_size</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sep_units</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">_bin_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">split_method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;split_method&#39;</span><span class="p">,</span><span class="s1">&#39;mean&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Using split_method = </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">split_method</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">min_top</span> <span class="o">=</span> <span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">,</span><span class="s1">&#39;min_top&#39;</span><span class="p">,</span><span class="nb">int</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">max_top</span> <span class="o">=</span> <span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">,</span><span class="s1">&#39;max_top&#39;</span><span class="p">,</span><span class="nb">int</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">bin_slop</span> <span class="o">=</span> <span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">,</span><span class="s1">&#39;bin_slop&#39;</span><span class="p">,</span><span class="nb">float</span><span class="p">,</span><span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_slop</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">bin_slop</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">max_good_slop</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">min_log_bin_size</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_slop</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_slop</span> <span class="o">&gt;</span> <span class="n">max_good_slop</span> <span class="o">+</span> <span class="mf">0.0001</span><span class="p">:</span>  <span class="c1"># Add some numerical slop</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Using bin_slop = </span><span class="si">%g</span><span class="s2">, bin_size = </span><span class="si">%g</span><span class="s2">, b = </span><span class="si">%g</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_slop</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">)</span><span class="o">+</span>
                <span class="s2">&quot;It is recommended to use bin_slop &lt;= </span><span class="si">%s</span><span class="s2"> in this case.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">%</span><span class="n">max_good_slop</span><span class="o">+</span>
                <span class="s2">&quot;Larger values of bin_slop (and hence b) may result in significant inaccuracies.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Using bin_slop = </span><span class="si">%g</span><span class="s2">, b = </span><span class="si">%g</span><span class="s2">&quot;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_slop</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">brute</span> <span class="o">=</span> <span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">,</span><span class="s1">&#39;brute&#39;</span><span class="p">,</span><span class="nb">bool</span><span class="p">,</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">brute</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Doing brute force calculation</span><span class="si">%s</span><span class="s2">.&quot;</span><span class="p">,</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">brute</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="s2">&quot;&quot;</span> <span class="ow">or</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">brute</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="s2">&quot; for first field&quot;</span> <span class="ow">or</span>
                             <span class="s2">&quot; for second field&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coords</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metric</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">min_rpar</span> <span class="o">=</span> <span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">,</span><span class="s1">&#39;min_rpar&#39;</span><span class="p">,</span><span class="nb">float</span><span class="p">,</span><span class="o">-</span><span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="o">.</span><span class="n">max</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">max_rpar</span> <span class="o">=</span> <span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">,</span><span class="s1">&#39;max_rpar&#39;</span><span class="p">,</span><span class="nb">float</span><span class="p">,</span><span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="o">.</span><span class="n">max</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_rpar</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_rpar</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;min_rpar must be &lt;= max_rpar&quot;</span><span class="p">)</span>
        <span class="n">period</span> <span class="o">=</span> <span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">,</span><span class="s1">&#39;period&#39;</span><span class="p">,</span><span class="nb">float</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">xperiod</span> <span class="o">=</span> <span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">,</span><span class="s1">&#39;xperiod&#39;</span><span class="p">,</span><span class="nb">float</span><span class="p">,</span><span class="n">period</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">yperiod</span> <span class="o">=</span> <span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">,</span><span class="s1">&#39;yperiod&#39;</span><span class="p">,</span><span class="nb">float</span><span class="p">,</span><span class="n">period</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">zperiod</span> <span class="o">=</span> <span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">,</span><span class="s1">&#39;zperiod&#39;</span><span class="p">,</span><span class="nb">float</span><span class="p">,</span><span class="n">period</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">var_method</span> <span class="o">=</span> <span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">,</span><span class="s1">&#39;var_method&#39;</span><span class="p">,</span><span class="nb">str</span><span class="p">,</span><span class="s1">&#39;shot&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">num_bootstrap</span> <span class="o">=</span> <span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">,</span><span class="s1">&#39;num_bootstrap&#39;</span><span class="p">,</span><span class="nb">int</span><span class="p">,</span><span class="mi">500</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># for jackknife, etc. store the results of each pair of patches.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">npatch1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch2</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rng</span> <span class="o">=</span> <span class="n">rng</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rng</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rng</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rng</span>

    <span class="c1"># Properties for all the read-only attributes (&quot;ro&quot; stands for &quot;read-only&quot;)</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">output_dots</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">output_dots</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bin_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">bin_type</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sep_units</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">sep_units</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_sep_units</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">_sep_units</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_log_sep_units</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">_log_sep_units</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">min_sep</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">min_sep</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">max_sep</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">max_sep</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bin_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">bin_size</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nbins</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">nbins</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">logr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">logr</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rnom</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">rnom</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">left_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">left_edges</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">right_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">right_edges</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">top_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">top_edges</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bottom_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">bottom_edges</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_bintype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">_bintype</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_nbins</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">_nbins</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_min_sep</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">_min_sep</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_max_sep</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">_max_sep</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_bin_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">_bin_size</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">split_method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">split_method</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">min_top</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">min_top</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">max_top</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">max_top</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bin_slop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">bin_slop</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">b</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">b</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">brute</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">brute</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">min_rpar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">min_rpar</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">max_rpar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">max_rpar</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">xperiod</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">xperiod</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">yperiod</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">yperiod</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">zperiod</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">zperiod</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">var_method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">var_method</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_bootstrap</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">num_bootstrap</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_d1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">_d1</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_d2</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">_d2</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;_corr&#39;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;_ok&#39;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>     <span class="c1"># Remake this as needed.</span>
        <span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;logger&#39;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>  <span class="c1"># Oh well.  This is just lost in the copy.  Can&#39;t be pickled.</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span> <span class="o">=</span> <span class="n">d</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_corr</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">setup_logger</span><span class="p">(</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">,</span><span class="s1">&#39;verbose&#39;</span><span class="p">,</span><span class="nb">int</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;log_file&#39;</span><span class="p">,</span><span class="kc">None</span><span class="p">))</span>

<div class="viewcode-block" id="BinnedCorr2.clear"><a class="viewcode-back" href="../../correlation2.html#treecorr.BinnedCorr2.clear">[docs]</a>    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Clear all data vectors, the results dict, and any related values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">npatch1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch2</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;_ok&#39;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nonzero</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return if there are any values accumulated yet.  (i.e. npairs &gt; 0)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npairs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_add_tot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">):</span>
        <span class="c1"># No op for all but NNCorrelation, which needs to add the tot value</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">_trivially_zero</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">metric</span><span class="p">):</span>
        <span class="c1"># For now, ignore the metric.  Just be conservative about how much space we need.</span>
        <span class="n">x1</span><span class="p">,</span><span class="n">y1</span><span class="p">,</span><span class="n">z1</span><span class="p">,</span><span class="n">s1</span> <span class="o">=</span> <span class="n">c1</span><span class="o">.</span><span class="n">_get_center_size</span><span class="p">()</span>
        <span class="n">x2</span><span class="p">,</span><span class="n">y2</span><span class="p">,</span><span class="n">z2</span><span class="p">,</span><span class="n">s2</span> <span class="o">=</span> <span class="n">c2</span><span class="o">.</span><span class="n">_get_center_size</span><span class="p">()</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">((</span><span class="n">x1</span><span class="o">-</span><span class="n">x2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y1</span><span class="o">-</span><span class="n">y2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">z1</span><span class="o">-</span><span class="n">z2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">d</span> <span class="o">&gt;</span> <span class="n">s1</span> <span class="o">+</span> <span class="n">s2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_max_sep</span><span class="p">)</span>  <span class="c1"># The 2* is where we are being conservative.</span>

    <span class="k">def</span> <span class="nf">_process_all_auto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cat1</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span> <span class="n">num_threads</span><span class="p">,</span> <span class="n">comm</span><span class="p">,</span> <span class="n">low_mem</span><span class="p">):</span>

        <span class="k">def</span> <span class="nf">is_my_job</span><span class="p">(</span><span class="n">my_indices</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="c1"># Helper function to figure out if a given (i,j) job should be done on the</span>
            <span class="c1"># current process.</span>

            <span class="c1"># Always my job if not using MPI.</span>
            <span class="k">if</span> <span class="n">my_indices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>

            <span class="c1"># Now the tricky part.  If using MPI, we need to divide up the jobs smartly.</span>
            <span class="c1"># The first point is to divvy up the auto jobs evenly.  This is where most of the</span>
            <span class="c1"># work is done, so we want those to be spreads as evenly as possibly across procs.</span>
            <span class="c1"># Therefore, if both indices are mine, then do the job.</span>
            <span class="c1"># This reduces the number of catalogs this machine needs to load up.</span>
            <span class="c1"># If the auto i,i and j,j are both my job, then i and j are already being loaded</span>
            <span class="c1"># on this machine, so also do that job.</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">my_indices</span> <span class="ow">and</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">my_indices</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Rank </span><span class="si">%d</span><span class="s2">: Job (</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">) is mine.&quot;</span><span class="p">,</span><span class="n">rank</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">True</span>

            <span class="c1"># If neither index is mine, then it&#39;s not my job.</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">my_indices</span> <span class="ow">and</span> <span class="n">j</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">my_indices</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>

            <span class="c1"># For the other jobs, we want to minimize how many other catalogs need to be</span>
            <span class="c1"># loaded.  Unfortunately, the nature of pairs is such that we can&#39;t reduce this</span>
            <span class="c1"># too much.  For the set of jobs i,j where i belongs to proc 1 and j belongs to proc 2,</span>
            <span class="c1"># half of these pairs need to be assigned to each proc.</span>
            <span class="c1"># The best I could figure for this is to give even i to proc 1 and odd i to proc 2.</span>
            <span class="c1"># This means proc 1 has to load all the j catalogs, but proc 2 can skip half the i</span>
            <span class="c1"># catalogs.  This would naively have the result that procs with lower indices</span>
            <span class="c1"># have to load more catalogs than those with higher indices, since i &lt; j.</span>
            <span class="c1"># So we reverse the procedure when j-i &gt; n/2 to spread out the I/O more.</span>
            <span class="k">if</span> <span class="n">j</span><span class="o">-</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">//</span><span class="mi">2</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="p">(</span><span class="mi">0</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">my_indices</span> <span class="k">else</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">j</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="p">(</span><span class="mi">0</span> <span class="k">if</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">my_indices</span> <span class="k">else</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ret</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Rank </span><span class="si">%d</span><span class="s2">: Job (</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">) is mine.&quot;</span><span class="p">,</span><span class="n">rank</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">ret</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cat1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">cat1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">npatch</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">process_auto</span><span class="p">(</span><span class="n">cat1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">metric</span><span class="p">,</span><span class="n">num_threads</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># When patch processing, keep track of the pair-wise results.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch1</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">npatch1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch2</span> <span class="o">=</span> <span class="n">cat1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">npatch</span> <span class="k">if</span> <span class="n">cat1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">npatch</span> <span class="o">!=</span> <span class="mi">1</span> <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="n">cat1</span><span class="p">)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch1</span>

            <span class="c1"># Setup for deciding when this is my job.</span>
            <span class="k">if</span> <span class="n">comm</span><span class="p">:</span>
                <span class="n">size</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">Get_size</span><span class="p">()</span>
                <span class="n">rank</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">Get_rank</span><span class="p">()</span>
                <span class="n">my_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">rank</span> <span class="o">//</span> <span class="n">size</span><span class="p">,</span> <span class="n">n</span> <span class="o">*</span> <span class="p">(</span><span class="n">rank</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="n">size</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Rank </span><span class="si">%d</span><span class="s2">: My indices are </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">rank</span><span class="p">,</span><span class="n">my_indices</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">my_indices</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="n">temp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">temp</span><span class="o">.</span><span class="n">results</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># Don&#39;t mess up the original results</span>
            <span class="k">for</span> <span class="n">ii</span><span class="p">,</span><span class="n">c1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cat1</span><span class="p">):</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">c1</span><span class="o">.</span><span class="n">patch</span> <span class="k">if</span> <span class="n">c1</span><span class="o">.</span><span class="n">patch</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">ii</span>
                <span class="k">if</span> <span class="n">is_my_job</span><span class="p">(</span><span class="n">my_indices</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                    <span class="n">temp</span><span class="o">.</span><span class="n">_clear</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Process patch </span><span class="si">%d</span><span class="s1"> auto&#39;</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">temp</span><span class="o">.</span><span class="n">process_auto</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span><span class="n">metric</span><span class="p">,</span><span class="n">num_threads</span><span class="p">)</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">)]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">)]</span> <span class="o">+=</span> <span class="n">temp</span>
                    <span class="bp">self</span> <span class="o">+=</span> <span class="n">temp</span>
                <span class="k">for</span> <span class="n">jj</span><span class="p">,</span><span class="n">c2</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">cat1</span><span class="p">))[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">j</span> <span class="o">=</span> <span class="n">c2</span><span class="o">.</span><span class="n">patch</span> <span class="k">if</span> <span class="n">c2</span><span class="o">.</span><span class="n">patch</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">jj</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span> <span class="ow">and</span> <span class="n">is_my_job</span><span class="p">(</span><span class="n">my_indices</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                        <span class="n">temp</span><span class="o">.</span><span class="n">_clear</span><span class="p">()</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trivially_zero</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span><span class="n">c2</span><span class="p">,</span><span class="n">metric</span><span class="p">):</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Process patches </span><span class="si">%d</span><span class="s1">,</span><span class="si">%d</span><span class="s1"> cross&#39;</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
                            <span class="n">temp</span><span class="o">.</span><span class="n">process_cross</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span><span class="n">c2</span><span class="p">,</span><span class="n">metric</span><span class="p">,</span><span class="n">num_threads</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Skipping </span><span class="si">%d</span><span class="s1">,</span><span class="si">%d</span><span class="s1"> pair, which are too far apart &#39;</span> <span class="o">+</span>
                                             <span class="s1">&#39;for this set of separations&#39;</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">temp</span><span class="o">.</span><span class="n">nonzero</span><span class="p">:</span>
                            <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span> <span class="o">+=</span> <span class="n">temp</span>
                            <span class="bp">self</span> <span class="o">+=</span> <span class="n">temp</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># NNCorrelation needs to add the tot value</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_add_tot</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">low_mem</span> <span class="ow">and</span> <span class="n">jj</span> <span class="o">!=</span> <span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span>
                            <span class="c1"># Don&#39;t unload i+1, since that&#39;s the next one we&#39;ll need.</span>
                            <span class="n">c2</span><span class="o">.</span><span class="n">unload</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">low_mem</span><span class="p">:</span>
                    <span class="n">c1</span><span class="o">.</span><span class="n">unload</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">comm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">rank</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">Get_rank</span><span class="p">()</span>
                <span class="n">size</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">Get_size</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Rank </span><span class="si">%d</span><span class="s2">: Completed jobs </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">rank</span><span class="p">,</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
                <span class="c1"># Send all the results back to rank 0 process.</span>
                <span class="k">if</span> <span class="n">rank</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">comm</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">size</span><span class="p">):</span>
                        <span class="n">temp</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
                        <span class="bp">self</span> <span class="o">+=</span> <span class="n">temp</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">temp</span><span class="o">.</span><span class="n">results</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_process_all_cross</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cat1</span><span class="p">,</span> <span class="n">cat2</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span> <span class="n">num_threads</span><span class="p">,</span> <span class="n">comm</span><span class="p">,</span> <span class="n">low_mem</span><span class="p">):</span>

        <span class="k">def</span> <span class="nf">is_my_job</span><span class="p">(</span><span class="n">my_indices</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">):</span>
            <span class="c1"># Helper function to figure out if a given (i,j) job should be done on the</span>
            <span class="c1"># current process.</span>

            <span class="c1"># Always my job if not using MPI.</span>
            <span class="k">if</span> <span class="n">my_indices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>

            <span class="c1"># This is much simpler than in the auto case, since the set of catalogs for</span>
            <span class="c1"># cat1 and cat2 are different, we can just split up one of them among the jobs.</span>
            <span class="k">if</span> <span class="n">n1</span> <span class="o">&gt;</span> <span class="n">n2</span><span class="p">:</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">j</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">my_indices</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Rank </span><span class="si">%d</span><span class="s2">: Job (</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">) is mine.&quot;</span><span class="p">,</span><span class="n">rank</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">,</span><span class="s1">&#39;pairwise&#39;</span><span class="p">,</span><span class="nb">bool</span><span class="p">,</span><span class="kc">False</span><span class="p">):</span>
            <span class="kn">import</span> <span class="nn">warnings</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The pairwise option is slated to be removed in a future version. &quot;</span><span class="o">+</span>
                          <span class="s2">&quot;If you are actually using this parameter usefully, please &quot;</span><span class="o">+</span>
                          <span class="s2">&quot;open an issue to describe your use case.&quot;</span><span class="p">,</span> <span class="ne">FutureWarning</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cat1</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cat2</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Number of files for 1 and 2 must be equal for pairwise.&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">c1</span><span class="p">,</span><span class="n">c2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">cat1</span><span class="p">,</span><span class="n">cat2</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">c1</span><span class="o">.</span><span class="n">ntot</span> <span class="o">!=</span> <span class="n">c2</span><span class="o">.</span><span class="n">ntot</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Number of objects must be equal for pairwise.&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">process_pairwise</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span><span class="n">c2</span><span class="p">,</span><span class="n">metric</span><span class="p">,</span><span class="n">num_threads</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">cat1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">cat2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">cat1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">npatch</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">cat2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">npatch</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">process_cross</span><span class="p">(</span><span class="n">cat1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">cat2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">metric</span><span class="p">,</span><span class="n">num_threads</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># When patch processing, keep track of the pair-wise results.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch1</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">npatch1</span> <span class="o">=</span> <span class="n">cat1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">npatch</span> <span class="k">if</span> <span class="n">cat1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">npatch</span> <span class="o">!=</span> <span class="mi">1</span> <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="n">cat1</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">npatch2</span> <span class="o">=</span> <span class="n">cat2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">npatch</span> <span class="k">if</span> <span class="n">cat2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">npatch</span> <span class="o">!=</span> <span class="mi">1</span> <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="n">cat2</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch1</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch2</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch1</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch2</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Cross correlation requires both catalogs use the same patches.&quot;</span><span class="p">)</span>

            <span class="c1"># Setup for deciding when this is my job.</span>
            <span class="n">n1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch1</span>
            <span class="n">n2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch2</span>
            <span class="k">if</span> <span class="n">comm</span><span class="p">:</span>
                <span class="n">size</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">Get_size</span><span class="p">()</span>
                <span class="n">rank</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">Get_rank</span><span class="p">()</span>
                <span class="n">n</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span><span class="n">n2</span><span class="p">)</span>
                <span class="n">my_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">rank</span> <span class="o">//</span> <span class="n">size</span><span class="p">,</span> <span class="n">n</span> <span class="o">*</span> <span class="p">(</span><span class="n">rank</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="n">size</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Rank </span><span class="si">%d</span><span class="s2">: My indices are </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">rank</span><span class="p">,</span><span class="n">my_indices</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">my_indices</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="n">temp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">temp</span><span class="o">.</span><span class="n">results</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># Don&#39;t mess up the original results</span>
            <span class="k">for</span> <span class="n">ii</span><span class="p">,</span><span class="n">c1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cat1</span><span class="p">):</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">c1</span><span class="o">.</span><span class="n">patch</span> <span class="k">if</span> <span class="n">c1</span><span class="o">.</span><span class="n">patch</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">ii</span>
                <span class="k">for</span> <span class="n">jj</span><span class="p">,</span><span class="n">c2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cat2</span><span class="p">):</span>
                    <span class="n">j</span> <span class="o">=</span> <span class="n">c2</span><span class="o">.</span><span class="n">patch</span> <span class="k">if</span> <span class="n">c2</span><span class="o">.</span><span class="n">patch</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">jj</span>
                    <span class="k">if</span> <span class="n">is_my_job</span><span class="p">(</span><span class="n">my_indices</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">):</span>
                        <span class="n">temp</span><span class="o">.</span><span class="n">_clear</span><span class="p">()</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trivially_zero</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span><span class="n">c2</span><span class="p">,</span><span class="n">metric</span><span class="p">):</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Process patches </span><span class="si">%d</span><span class="s1">,</span><span class="si">%d</span><span class="s1"> cross&#39;</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
                            <span class="n">temp</span><span class="o">.</span><span class="n">process_cross</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span><span class="n">c2</span><span class="p">,</span><span class="n">metric</span><span class="p">,</span><span class="n">num_threads</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Skipping </span><span class="si">%d</span><span class="s1">,</span><span class="si">%d</span><span class="s1"> pair, which are too far apart &#39;</span> <span class="o">+</span>
                                             <span class="s1">&#39;for this set of separations&#39;</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">temp</span><span class="o">.</span><span class="n">nonzero</span> <span class="ow">or</span> <span class="n">i</span><span class="o">==</span><span class="n">j</span> <span class="ow">or</span> <span class="n">n1</span><span class="o">==</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">n2</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                            <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span> <span class="o">+=</span> <span class="n">temp</span>
                            <span class="bp">self</span> <span class="o">+=</span> <span class="n">temp</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># NNCorrelation needs to add the tot value</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_add_tot</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">low_mem</span><span class="p">:</span>
                            <span class="n">c2</span><span class="o">.</span><span class="n">unload</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">low_mem</span><span class="p">:</span>
                    <span class="n">c1</span><span class="o">.</span><span class="n">unload</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">comm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">rank</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">Get_rank</span><span class="p">()</span>
                <span class="n">size</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">Get_size</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Rank </span><span class="si">%d</span><span class="s2">: Completed jobs </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">rank</span><span class="p">,</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
                <span class="c1"># Send all the results back to rank 0 process.</span>
                <span class="k">if</span> <span class="n">rank</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">comm</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">size</span><span class="p">):</span>
                        <span class="n">temp</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
                        <span class="bp">self</span> <span class="o">+=</span> <span class="n">temp</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">temp</span><span class="o">.</span><span class="n">results</span><span class="p">)</span>

<div class="viewcode-block" id="BinnedCorr2.getStat"><a class="viewcode-back" href="../../correlation2.html#treecorr.BinnedCorr2.getStat">[docs]</a>    <span class="k">def</span> <span class="nf">getStat</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The standard statistic for the current correlation object as a 1-d array.</span>

<span class="sd">        Usually, this is just self.xi.  But if the metric is TwoD, this becomes self.xi.ravel().</span>
<span class="sd">        And for `GGCorrelation`, it is the concatenation of self.xip and self.xim.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span></div>

<div class="viewcode-block" id="BinnedCorr2.getWeight"><a class="viewcode-back" href="../../correlation2.html#treecorr.BinnedCorr2.getWeight">[docs]</a>    <span class="k">def</span> <span class="nf">getWeight</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The weight array for the current correlation object as a 1-d array.</span>

<span class="sd">        This is the weight array corresponding to `getStat`. Usually just self.weight, but</span>
<span class="sd">        raveled for TwoD and duplicated for GGCorrelation to match what `getStat` does in</span>
<span class="sd">        those cases.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span></div>

<div class="viewcode-block" id="BinnedCorr2.estimate_cov"><a class="viewcode-back" href="../../correlation2.html#treecorr.BinnedCorr2.estimate_cov">[docs]</a>    <span class="k">def</span> <span class="nf">estimate_cov</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Estimate the covariance matrix based on the data</span>

<span class="sd">        This function will calculate an estimate of the covariance matrix according to the</span>
<span class="sd">        given method.</span>

<span class="sd">        Options for ``method`` include:</span>

<span class="sd">            - &#39;shot&#39; = The variance based on &quot;shot noise&quot; only.  This includes the Poisson</span>
<span class="sd">              counts of points for N statistics, shape noise for G statistics, and the observed</span>
<span class="sd">              scatter in the values for K statistics.  In this case, the returned covariance</span>
<span class="sd">              matrix will be diagonal, since there is no way to estimate the off-diagonal terms.</span>
<span class="sd">            - &#39;jackknife&#39; = A jackknife estimate of the covariance matrix based on the scatter</span>
<span class="sd">              in the measurement when excluding one patch at a time.</span>
<span class="sd">            - &#39;sample&#39; = An estimate based on the sample covariance of a set of samples,</span>
<span class="sd">              taken as the patches of the input catalog.</span>
<span class="sd">            - &#39;bootstrap&#39; = A bootstrap covariance estimate. It selects patches at random with</span>
<span class="sd">              replacement and then generates the statistic using all the auto-correlations at</span>
<span class="sd">              their selected repetition plus all the cross terms that aren&#39;t actually auto terms.</span>
<span class="sd">            - &#39;marked_bootstrap&#39; = An estimate based on a marked-point bootstrap resampling of the</span>
<span class="sd">              patches.  Similar to bootstrap, but only samples the patches of the first catalog and</span>
<span class="sd">              uses all patches from the second catalog that correspond to each patch selection of</span>
<span class="sd">              the first catalog.  cf. https://ui.adsabs.harvard.edu/abs/2008ApJ...681..726L/</span>

<span class="sd">        Both &#39;bootstrap&#39; and &#39;marked_bootstrap&#39; use the num_bootstrap parameter, which can be set on</span>
<span class="sd">        construction.</span>

<span class="sd">        .. note::</span>

<span class="sd">            For most classes, there is only a single statistic, so this calculates a covariance</span>
<span class="sd">            matrix for that vector.  `GGCorrelation` has two: ``xip`` and ``xim``, so in this</span>
<span class="sd">            case the full data vector is ``xip`` followed by ``xim``, and this calculates the</span>
<span class="sd">            covariance matrix for that full vector including both statistics.  The helper</span>
<span class="sd">            function `getStat` returns the relevant statistic in all cases.</span>

<span class="sd">        In all cases, the relevant processing needs to already have been completed and finalized.</span>
<span class="sd">        And for all methods other than &#39;shot&#39;, the processing should have involved an appropriate</span>
<span class="sd">        number of patches -- preferably more patches than the length of the vector for your</span>
<span class="sd">        statistic, although this is not checked.</span>

<span class="sd">        The default data vector to use for the covariance matrix is given by the method</span>
<span class="sd">        `getStat`.  As noted above, this is usually just self.xi.  However, there is an option</span>
<span class="sd">        to compute the covariance of some other function of the correlation object by providing</span>
<span class="sd">        an arbitrary function, ``func``, which should act on the current correlation object</span>
<span class="sd">        and return the data vector of interest.</span>

<span class="sd">        For instance, for an `NGCorrelation`, you might want to compute the covariance of the</span>
<span class="sd">        imaginary part, ``ng.xi_im``, rather than the real part.  In this case you could use</span>

<span class="sd">            &gt;&gt;&gt; func = lambda ng: ng.xi_im</span>

<span class="sd">        The return value from this func should be a single numpy array. (This is not directly</span>
<span class="sd">        checked, but you&#39;ll probably get some kind of exception if it doesn&#39;t behave as expected.)</span>

<span class="sd">        .. note::</span>

<span class="sd">            The optional ``func`` parameter is not valid in conjunction with ``method=&#39;shot&#39;``.</span>
<span class="sd">            It only works for the methods that are based on patch combinations.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            method (str):       Which method to use to estimate the covariance matrix.</span>
<span class="sd">            func (function):    A unary function that acts on the current correlation object and</span>
<span class="sd">                                returns the desired data vector. [default: None, which is</span>
<span class="sd">                                equivalent to ``lambda corr: corr.getStat()``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A numpy array with the estimated covariance matrix.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Need to convert it to a function of the first item in the list.</span>
            <span class="n">all_func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">corrs</span><span class="p">:</span> <span class="n">func</span><span class="p">(</span><span class="n">corrs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">all_func</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">estimate_multi_cov</span><span class="p">([</span><span class="bp">self</span><span class="p">],</span> <span class="n">method</span><span class="p">,</span> <span class="n">all_func</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_set_num_threads</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_threads</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">num_threads</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">num_threads</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;num_threads&#39;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
        <span class="c1"># Recheck.</span>
        <span class="k">if</span> <span class="n">num_threads</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Set num_threads automatically&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Set num_threads = </span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">,</span><span class="n">num_threads</span><span class="p">)</span>
        <span class="n">set_omp_threads</span><span class="p">(</span><span class="n">num_threads</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_metric</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span> <span class="n">coords1</span><span class="p">,</span> <span class="n">coords2</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">metric</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">metric</span> <span class="o">=</span> <span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">,</span><span class="s1">&#39;metric&#39;</span><span class="p">,</span><span class="nb">str</span><span class="p">,</span><span class="s1">&#39;Euclidean&#39;</span><span class="p">)</span>
        <span class="n">coords</span><span class="p">,</span> <span class="n">metric</span> <span class="o">=</span> <span class="n">parse_metric</span><span class="p">(</span><span class="n">metric</span><span class="p">,</span> <span class="n">coords1</span><span class="p">,</span> <span class="n">coords2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">coords</span> <span class="o">!=</span> <span class="s1">&#39;3d&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_rpar</span> <span class="o">!=</span> <span class="o">-</span><span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="o">.</span><span class="n">max</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;min_rpar is only valid for 3d coordinates&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_rpar</span> <span class="o">!=</span> <span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="o">.</span><span class="n">max</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;max_rpar is only valid for 3d coordinates&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sep_units</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span> <span class="ow">and</span> <span class="n">coords</span> <span class="o">==</span> <span class="s1">&#39;3d&#39;</span> <span class="ow">and</span> <span class="n">metric</span> <span class="o">!=</span> <span class="s1">&#39;Arc&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;sep_units is invalid with 3d coordinates. &quot;</span>
                             <span class="s2">&quot;min_sep and max_sep should be in the same units as r (or x,y,z).&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">metric</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">coords</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Detected a change in catalog coordinate systems.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">+</span>
                                    <span class="s2">&quot;This probably doesn&#39;t make sense!&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">metric</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metric</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Detected a change in metric.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">+</span>
                                    <span class="s2">&quot;This probably doesn&#39;t make sense!&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;Periodic&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">xperiod</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">yperiod</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="p">(</span><span class="n">coords</span><span class="o">==</span><span class="s1">&#39;3d&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">zperiod</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Periodic metric requires setting the period to use.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">xperiod</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">yperiod</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">zperiod</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;period options are not valid for </span><span class="si">%s</span><span class="s2"> metric.&quot;</span><span class="o">%</span><span class="n">metric</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coords</span> <span class="o">=</span> <span class="n">coords</span>  <span class="c1"># These are the regular string values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metric</span> <span class="o">=</span> <span class="n">metric</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_coords</span> <span class="o">=</span> <span class="n">coord_enum</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>  <span class="c1"># These are the C++-layer enums</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_metric</span> <span class="o">=</span> <span class="n">metric_enum</span><span class="p">(</span><span class="n">metric</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_apply_units</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span> <span class="o">==</span> <span class="s1">&#39;spherical&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;Euclidean&#39;</span><span class="p">:</span>
            <span class="c1"># Then our distances are all angles.  Convert from the chord distance to a real angle.</span>
            <span class="c1"># L = 2 sin(theta/2)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">meanr</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meanr</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">meanlogr</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span> <span class="mf">2.</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meanlogr</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meanr</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sep_units</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meanlogr</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_log_sep_units</span>

    <span class="k">def</span> <span class="nf">_get_minmax_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;Euclidean&#39;</span><span class="p">:</span>
            <span class="c1"># The minimum size cell that will be useful is one where two cells that just barely</span>
            <span class="c1"># don&#39;t split have (d + s1 + s2) = minsep</span>
            <span class="c1"># The largest s2 we need to worry about is s2 = 2s1.</span>
            <span class="c1"># i.e. d = minsep - 3s1  and s1 = 0.5 * bd</span>
            <span class="c1">#      d = minsep - 1.5 bd</span>
            <span class="c1">#      d = minsep / (1+1.5 b)</span>
            <span class="c1">#      s = 0.5 * b * minsep / (1+1.5 b)</span>
            <span class="c1">#        = b * minsep / (2+3b)</span>
            <span class="n">min_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_min_sep</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.</span><span class="o">+</span><span class="mf">3.</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">)</span>

            <span class="c1"># The maximum size cell that will be useful is one where a cell of size s will</span>
            <span class="c1"># be split at the maximum separation even if the other size = 0.</span>
            <span class="c1"># i.e. max_size = max_sep * b</span>
            <span class="n">max_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_sep</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span>
            <span class="k">return</span> <span class="n">min_size</span><span class="p">,</span> <span class="n">max_size</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># For other metrics, the above calculation doesn&#39;t really apply, so just skip</span>
            <span class="c1"># this relatively modest optimization and go all the way to the leaves.</span>
            <span class="c1"># (And for the max_size, always split 10 levels for the top-level cells.)</span>
            <span class="k">return</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span>

<div class="viewcode-block" id="BinnedCorr2.sample_pairs"><a class="viewcode-back" href="../../correlation2.html#treecorr.BinnedCorr2.sample_pairs">[docs]</a>    <span class="k">def</span> <span class="nf">sample_pairs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">cat1</span><span class="p">,</span> <span class="n">cat2</span><span class="p">,</span> <span class="n">min_sep</span><span class="p">,</span> <span class="n">max_sep</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a random sample of n pairs whose separations fall between min_sep and max_sep.</span>

<span class="sd">        This would typically be used to get some random subset of the indices of pairs that</span>
<span class="sd">        fell into a particular bin of the correlation.  E.g. to get 100 pairs from the third</span>
<span class="sd">        bin of a `BinnedCorr2` instance, corr, you could write::</span>

<span class="sd">            &gt;&gt;&gt; min_sep = corr.left_edges[2]   # third bin has i=2</span>
<span class="sd">            &gt;&gt;&gt; max_sep = corr.right_edges[2]</span>
<span class="sd">            &gt;&gt;&gt; i1, i2, sep = corr.sample_pairs(100, cat1, cat2, min_sep, max_sep)</span>

<span class="sd">        The min_sep and max_sep should use the same units as were defined when constructing</span>
<span class="sd">        the corr instance.</span>

<span class="sd">        The selection process will also use the same bin_slop as specified (either explicitly or</span>
<span class="sd">        implicitly) when constructing the corr instance.  This means that some of the pairs may</span>
<span class="sd">        have actual separations slightly outside of the specified range.  If you want a selection</span>
<span class="sd">        using an exact range without any slop, you should construct a new Correlation instance</span>
<span class="sd">        with bin_slop=0, and call sample_pairs with that.</span>

<span class="sd">        The returned separations will likewise correspond to the separation of the cells in the</span>
<span class="sd">        tree that TreeCorr used to place the pairs into the given bin.  Therefore, if these cells</span>
<span class="sd">        were not leaf cells, then they will not typically be equal to the real separations for the</span>
<span class="sd">        given metric.  If you care about the exact separations for each pair, you should either</span>
<span class="sd">        call sample_pairs from a Correlation instance with brute=True or recalculate the</span>
<span class="sd">        distances yourself from the original data.</span>

<span class="sd">        Also, note that min_sep and max_sep may be arbitrary.  There is no requirement that they</span>
<span class="sd">        be edges of one of the standard bins for this correlation function.  There is also no</span>
<span class="sd">        requirement that this correlation instance has already accumulated pairs via a call</span>
<span class="sd">        to process with these catalogs.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            n (int):            How many samples to return.</span>
<span class="sd">            cat1 (Catalog):     The catalog from which to sample the first object of each pair.</span>
<span class="sd">            cat2 (Catalog):     The catalog from which to sample the second object of each pair.</span>
<span class="sd">                                (This may be the same as cat1.)</span>
<span class="sd">            min_sep (float):    The minimum separation for the returned pairs (modulo some slop</span>
<span class="sd">                                allowed by the bin_slop parameter).</span>
<span class="sd">            max_sep (float):    The maximum separation for the returned pairs (modulo some slop</span>
<span class="sd">                                allowed by the bin_slop parameter).</span>
<span class="sd">            metric (str):       Which metric to use.  See `Metrics` for details.  (default:</span>
<span class="sd">                                self.metric, or &#39;Euclidean&#39; if not set yet)</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple containing</span>

<span class="sd">                - i1 (array): indices of objects from cat1</span>
<span class="sd">                - i2 (array): indices of objects from cat2</span>
<span class="sd">                - sep (array): separations of the pairs of objects (i1,i2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.util</span> <span class="kn">import</span> <span class="n">long_ptr</span> <span class="k">as</span> <span class="n">lp</span>
        <span class="kn">from</span> <span class="nn">.util</span> <span class="kn">import</span> <span class="n">double_ptr</span> <span class="k">as</span> <span class="n">dp</span>

        <span class="k">if</span> <span class="n">metric</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">metric</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;metric&#39;</span><span class="p">,</span> <span class="s1">&#39;Euclidean&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_set_metric</span><span class="p">(</span><span class="n">metric</span><span class="p">,</span> <span class="n">cat1</span><span class="o">.</span><span class="n">coords</span><span class="p">,</span> <span class="n">cat2</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>

        <span class="n">f1</span> <span class="o">=</span> <span class="n">cat1</span><span class="o">.</span><span class="n">field</span>
        <span class="n">f2</span> <span class="o">=</span> <span class="n">cat2</span><span class="o">.</span><span class="n">field</span>

        <span class="k">if</span> <span class="n">f1</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">f1</span><span class="o">.</span><span class="n">_coords</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coords</span><span class="p">:</span>
            <span class="c1"># I don&#39;t really know if it&#39;s possible to get the coords out of sync,</span>
            <span class="c1"># so the 2nd check might be superfluous.</span>
            <span class="c1"># The first one though is definitely possible, so we need to check that.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;In sample_pairs, making default field for cat1&quot;</span><span class="p">)</span>
            <span class="n">min_size</span><span class="p">,</span> <span class="n">max_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_minmax_size</span><span class="p">()</span>
            <span class="n">f1</span> <span class="o">=</span> <span class="n">cat1</span><span class="o">.</span><span class="n">getNField</span><span class="p">(</span><span class="n">min_size</span><span class="p">,</span> <span class="n">max_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">split_method</span><span class="p">,</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">brute</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">brute</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">min_top</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_top</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">f2</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">f2</span><span class="o">.</span><span class="n">_coords</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coords</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;In sample_pairs, making default field for cat2&quot;</span><span class="p">)</span>
            <span class="n">min_size</span><span class="p">,</span> <span class="n">max_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_minmax_size</span><span class="p">()</span>
            <span class="n">f2</span> <span class="o">=</span> <span class="n">cat2</span><span class="o">.</span><span class="n">getNField</span><span class="p">(</span><span class="n">min_size</span><span class="p">,</span> <span class="n">max_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">split_method</span><span class="p">,</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">brute</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">brute</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">min_top</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_top</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>

        <span class="c1"># Apply units to min_sep, max_sep:</span>
        <span class="n">min_sep</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sep_units</span>
        <span class="n">max_sep</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sep_units</span>

        <span class="n">i1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">i2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">sep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">ntot</span> <span class="o">=</span> <span class="n">_lib</span><span class="o">.</span><span class="n">SamplePairs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">corr</span><span class="p">,</span> <span class="n">f1</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">f2</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">min_sep</span><span class="p">,</span> <span class="n">max_sep</span><span class="p">,</span>
                                <span class="n">f1</span><span class="o">.</span><span class="n">_d</span><span class="p">,</span> <span class="n">f2</span><span class="o">.</span><span class="n">_d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coords</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bintype</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metric</span><span class="p">,</span>
                                <span class="n">lp</span><span class="p">(</span><span class="n">i1</span><span class="p">),</span> <span class="n">lp</span><span class="p">(</span><span class="n">i2</span><span class="p">),</span> <span class="n">dp</span><span class="p">(</span><span class="n">sep</span><span class="p">),</span> <span class="n">n</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ntot</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">ntot</span>
            <span class="n">i1</span> <span class="o">=</span> <span class="n">i1</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span>
            <span class="n">i2</span> <span class="o">=</span> <span class="n">i2</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span>
            <span class="n">sep</span> <span class="o">=</span> <span class="n">sep</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span>
        <span class="c1"># Convert back to nominal units</span>
        <span class="n">sep</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sep_units</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Sampled </span><span class="si">%d</span><span class="s2"> pairs out of a total of </span><span class="si">%d</span><span class="s2">.&quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">ntot</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">,</span> <span class="n">sep</span></div>

    <span class="c1"># Some helper functions that are relevant for doing the covariance stuff below.</span>
    <span class="c1"># Note: the word &quot;pairs&quot; in many of these is appropriate for 2pt, but in the 3pt case</span>
    <span class="c1"># (cf. binnedcorr3.py), these actually refer to triples (i,j,k).</span>

    <span class="k">def</span> <span class="nf">_get_npatch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npatch1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_calculate_xi_from_pairs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pairs</span><span class="p">):</span>
        <span class="c1"># Compute the xi data vector for the given list of pairs.</span>
        <span class="c1"># pairs is input as a list of (i,j) values.</span>

        <span class="c1"># This is the normal calculation.  It needs to be overridden when there are randoms.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sum</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="n">ij</span><span class="p">]</span> <span class="k">for</span> <span class="n">ij</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_finalize</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_jackknife_pairs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># k=0 here.</span>
            <span class="k">return</span> <span class="p">[</span> <span class="p">[(</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">j</span><span class="o">!=</span><span class="n">i</span><span class="p">]</span>
                     <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npatch1</span><span class="p">)</span> <span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch1</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># j=0 here.</span>
            <span class="k">return</span> <span class="p">[</span> <span class="p">[(</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span><span class="o">!=</span><span class="n">i</span><span class="p">]</span>
                     <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npatch1</span><span class="p">)</span> <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch1</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch2</span>
            <span class="c1"># For each i:</span>
            <span class="c1">#    Select all pairs where neither is i.</span>
            <span class="k">return</span> <span class="p">[</span> <span class="p">[(</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">j</span><span class="o">!=</span><span class="n">i</span> <span class="ow">and</span> <span class="n">k</span><span class="o">!=</span><span class="n">i</span><span class="p">]</span>
                     <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npatch1</span><span class="p">)</span> <span class="p">]</span>

    <span class="k">def</span> <span class="nf">_sample_pairs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># k=0 here.</span>
            <span class="k">return</span> <span class="p">[</span> <span class="p">[(</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">j</span><span class="o">==</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npatch1</span><span class="p">)</span> <span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch1</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># j=0 here.</span>
            <span class="k">return</span> <span class="p">[</span> <span class="p">[(</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span><span class="o">==</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npatch1</span><span class="p">)</span> <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch1</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch2</span>
            <span class="c1"># Note: It&#39;s not obvious to me a priori which of these should be the right choice.</span>
            <span class="c1">#       Empirically, they both underestimate the variance, but the second one</span>
            <span class="c1">#       does so less on the tests I have in test_patch.py.  So that&#39;s the one I&#39;m</span>
            <span class="c1">#       using.</span>
            <span class="c1"># For each i:</span>
            <span class="c1">#    Select all pairs where either is i.</span>
            <span class="c1">#vpairs = [ [(j,k) for j,k in self.results.keys() if j==i or k==i]</span>
            <span class="c1">#           for i in range(self.npatch1) ]</span>
            <span class="c1"># For each i:</span>
            <span class="c1">#    Select all pairs where first is i.</span>
            <span class="k">return</span> <span class="p">[</span> <span class="p">[(</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">j</span><span class="o">==</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npatch1</span><span class="p">)</span> <span class="p">]</span>

    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">_ok</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ok</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">npatch1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">:</span>
            <span class="n">ok</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">ok</span>

    <span class="k">def</span> <span class="nf">_marked_pairs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indx</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indx</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ok</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch1</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indx</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ok</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch1</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch2</span>
            <span class="c1"># Select all pairs where first point is in indx (repeating i as appropriate)</span>
            <span class="k">return</span> <span class="p">[</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indx</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npatch2</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ok</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="p">]</span>

    <span class="k">def</span> <span class="nf">_bootstrap_pairs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indx</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indx</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ok</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch1</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indx</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ok</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch1</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch2</span>
            <span class="c1"># Include all represented auto-correlations once, repeating as appropriate.</span>
            <span class="c1"># This needs to be done separately from the below step to avoid extra pairs (i,i)</span>
            <span class="c1"># that you would get by looping i in indx and j in indx for cases where i=j at</span>
            <span class="c1"># different places in the indx list.  E.g. if i=3 shows up 3 times in indx, then</span>
            <span class="c1"># the naive way would get 9 instance of (3,3), whereas we only want 3 instances.</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indx</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ok</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="p">]</span>

            <span class="c1"># And all other pairs that aren&#39;t really auto-correlations.</span>
            <span class="c1"># These can happen at their natural multiplicity from i and j loops.</span>
            <span class="c1"># Note: This is way faster with the precomputed ok matrix.</span>
            <span class="c1"># Like 0.005 seconds per call rather than 1.2 seconds for 128 patches!</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indx</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">indx</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ok</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="ow">and</span> <span class="n">i</span><span class="o">!=</span><span class="n">j</span> <span class="p">])</span>
            <span class="k">return</span> <span class="n">ret</span></div>


<div class="viewcode-block" id="estimate_multi_cov"><a class="viewcode-back" href="../../correlation2.html#treecorr.estimate_multi_cov">[docs]</a><span class="k">def</span> <span class="nf">estimate_multi_cov</span><span class="p">(</span><span class="n">corrs</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Estimate the covariance matrix of multiple statistics.</span>

<span class="sd">    This is like the method `BinnedCorr2.estimate_cov`, except that it will acoommodate</span>
<span class="sd">    multiple statistics from a list ``corrs`` of `BinnedCorr2` objects.</span>

<span class="sd">    Options for ``method`` include:</span>

<span class="sd">        - &#39;shot&#39; = The variance based on &quot;shot noise&quot; only.  This includes the Poisson</span>
<span class="sd">          counts of points for N statistics, shape noise for G statistics, and the observed</span>
<span class="sd">          scatter in the values for K statistics.  In this case, the returned covariance</span>
<span class="sd">          matrix will be diagonal, since there is no way to estimate the off-diagonal terms.</span>
<span class="sd">        - &#39;jackknife&#39; = A jackknife estimate of the covariance matrix based on the scatter</span>
<span class="sd">          in the measurement when excluding one patch at a time.</span>
<span class="sd">        - &#39;sample&#39; = An estimate based on the sample covariance of a set of samples,</span>
<span class="sd">          taken as the patches of the input catalog.</span>
<span class="sd">        - &#39;bootstrap&#39; = A bootstrap covariance estimate. It selects patches at random with</span>
<span class="sd">          replacement and then generates the statistic using all the auto-correlations at</span>
<span class="sd">          their selected repetition plus all the cross terms that aren&#39;t actually auto terms.</span>
<span class="sd">        - &#39;marked_bootstrap&#39; = An estimate based on a marked-point bootstrap resampling of the</span>
<span class="sd">          patches.  Similar to bootstrap, but only samples the patches of the first catalog and</span>
<span class="sd">          uses all patches from the second catalog that correspond to each patch selection of</span>
<span class="sd">          the first catalog.  cf. https://ui.adsabs.harvard.edu/abs/2008ApJ...681..726L/</span>

<span class="sd">    Both &#39;bootstrap&#39; and &#39;marked_bootstrap&#39; use the num_bootstrap parameter, which can be set on</span>
<span class="sd">    construction.</span>

<span class="sd">    For example, to find the combined covariance matrix for an NG tangential shear statistc,</span>
<span class="sd">    along with the GG xi+ and xi- from the same area, using jackknife covariance estimation,</span>
<span class="sd">    you would write::</span>

<span class="sd">        &gt;&gt;&gt; cov = treecorr.estimate_multi_cov([ng,gg], &#39;jackknife&#39;)</span>

<span class="sd">    In all cases, the relevant processing needs to already have been completed and finalized.</span>
<span class="sd">    And for all methods other than &#39;shot&#39;, the processing should have involved an appropriate</span>
<span class="sd">    number of patches -- preferably more patches than the length of the vector for your</span>
<span class="sd">    statistic, although this is not checked.</span>

<span class="sd">    The default order of the covariance matrix is to simply concatenate the data vectors</span>
<span class="sd">    for each corr in the list ``corrs``.  However, if you want to do something more complicated,</span>
<span class="sd">    you may provide an arbitrary function, ``func``, which should act on the list of correlations.</span>
<span class="sd">    For instance, if you have several `GGCorrelation` objects and would like to order the</span>
<span class="sd">    covariance such that all xi+ results come first, and then all xi- results, you could use</span>

<span class="sd">        &gt;&gt;&gt; func = lambda corrs: np.concatenate([c.xip for c in corrs] + [c.xim for c in corrs])</span>

<span class="sd">    Or if you want to compute the covariance matrix of some derived quantity like the ratio</span>
<span class="sd">    of two correlations, you could use</span>

<span class="sd">        &gt;&gt;&gt; func = lambda corrs: corrs[0].xi / corrs[1].xi</span>

<span class="sd">    The return value from this func should be a single numpy array. (This is not directly</span>
<span class="sd">    checked, but you&#39;ll probably get some kind of exception if it doesn&#39;t behave as expected.)</span>

<span class="sd">    .. note::</span>

<span class="sd">        The optional ``func`` parameter is not valid in conjunction with ``method=&#39;shot&#39;``.</span>
<span class="sd">        It only works for the methods that are based on patch combinations.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        corrs (list):       A list of `BinnedCorr2` instances.</span>
<span class="sd">        method (str):       Which method to use to estimate the covariance matrix.</span>
<span class="sd">        func (function):    A unary function that takes the list ``corrs`` and returns the</span>
<span class="sd">                            desired full data vector. [default: None, which is equivalent to</span>
<span class="sd">                            ``lambda corrs: np.concatenate([c.getStat() for c in corrs])``]</span>

<span class="sd">    Returns:</span>
<span class="sd">        A numpy array with the estimated covariance matrix.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;shot&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;func is invalid with method=&#39;shot&#39;&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_cov_shot</span><span class="p">(</span><span class="n">corrs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">corrs</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">c</span><span class="o">.</span><span class="n">getStat</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">corrs</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;jackknife&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_cov_jackknife</span><span class="p">(</span><span class="n">corrs</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;bootstrap&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_cov_bootstrap</span><span class="p">(</span><span class="n">corrs</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;marked_bootstrap&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_cov_marked</span><span class="p">(</span><span class="n">corrs</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;sample&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_cov_sample</span><span class="p">(</span><span class="n">corrs</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid method: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="o">%</span><span class="n">method</span><span class="p">)</span></div>

<span class="k">def</span> <span class="nf">_make_cov_design_matrix</span><span class="p">(</span><span class="n">corrs</span><span class="p">,</span> <span class="n">plist</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
    <span class="c1"># plist has the pairs to use for each row in the design matrix for each correlation fn.</span>
    <span class="c1"># It is a list by row, each element is a list by corr fn of tuples (i,j), being the indices</span>
    <span class="c1"># to use from the results dict.</span>
    <span class="c1"># We aggregate and finalize each correlation function based on those pairs, and then call</span>
    <span class="c1"># the function func on that list of correlation objects.  This is the data vector for</span>
    <span class="c1"># each row in the design matrix.</span>
    <span class="c1"># We also make a parallel array of the total weight in each row in case the calling routing</span>
    <span class="c1"># needs it. So far, only sample uses the returned w, but it&#39;s very little overhead to compute</span>
    <span class="c1"># it, and only a small memory overhead to build that array and return it.</span>

    <span class="c1"># Make a copy of the correlation objects, so we can overwrite things without breaking</span>
    <span class="c1"># the original.</span>
    <span class="n">corrs</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">corrs</span><span class="p">]</span>

    <span class="c1"># Figure out the shape of the design matrix.</span>
    <span class="n">v1</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">corrs</span><span class="p">)</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">v1</span><span class="o">.</span><span class="n">dtype</span>
    <span class="n">vsize</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span>
    <span class="n">nrows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">plist</span><span class="p">)</span>

    <span class="c1"># Make the empty return arrays.</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nrows</span><span class="p">,</span><span class="n">vsize</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nrows</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">row</span><span class="p">,</span> <span class="n">pairs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">plist</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">cpairs</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">corrs</span><span class="p">,</span> <span class="n">pairs</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cpairs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># This will cause problems downstream if we let it go.</span>
                <span class="c1"># It probably indicates user error, using an inappropriate covariance estimator.</span>
                <span class="c1"># So warn about it, and then do something not too crazy.</span>
                <span class="n">c</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;WARNING: A xi for calculating the </span><span class="si">%s</span><span class="s2"> covariance has no &quot;</span><span class="o">%</span><span class="n">name</span> <span class="o">+</span>
                               <span class="s2">&quot;patch pairs.  This probably means these patch specifications &quot;</span>
                               <span class="s2">&quot;are inappropriate for these data.&quot;</span><span class="p">)</span>
                <span class="n">c</span><span class="o">.</span><span class="n">_clear</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">c</span><span class="o">.</span><span class="n">_calculate_xi_from_pairs</span><span class="p">(</span><span class="n">cpairs</span><span class="p">)</span>
        <span class="n">v</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">corrs</span><span class="p">)</span>
        <span class="n">w</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">getWeight</span><span class="p">())</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">corrs</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">v</span><span class="p">,</span><span class="n">w</span>

<span class="k">def</span> <span class="nf">_cov_shot</span><span class="p">(</span><span class="n">corrs</span><span class="p">):</span>
    <span class="c1"># Shot noise &quot;covariance&quot; is just 1/RR or var(g)/weight or var(k)/weight, etc.</span>
    <span class="c1"># Except for NN, the denominator is always corr.weight.</span>
    <span class="c1"># For NN, the denominator is set by calculateXi to be RR.weight.</span>
    <span class="c1"># The numerators are set appropriately for each kind of correlation function as _var_num</span>
    <span class="c1"># when doing finalize, or for NN also in calculateXi.</span>
    <span class="c1"># We return it as a covariance matrix for consistency with the other cov functions,</span>
    <span class="c1"># but the off diagonal terms are all zero.</span>
    <span class="n">vlist</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">corrs</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">getWeight</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">mask1</span> <span class="o">=</span> <span class="n">v</span> <span class="o">!=</span> <span class="mi">0</span>
        <span class="c1"># Note: if w=0 anywhere, leave v=0 there, rather than divide by zero.</span>
        <span class="n">v</span><span class="p">[</span><span class="n">mask1</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">_var_num</span> <span class="o">/</span> <span class="n">v</span><span class="p">[</span><span class="n">mask1</span><span class="p">]</span>
        <span class="n">vlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">vlist</span><span class="p">))</span>  <span class="c1"># Return as a covariance matrix</span>

<span class="k">def</span> <span class="nf">_check_patch_nums</span><span class="p">(</span><span class="n">corrs</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
    <span class="c1"># Figure out what pairs (i,j) are possible for these correlation functions.</span>
    <span class="c1"># Check that the patches used are compatible, and return the npatch to use.</span>

    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">corrs</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">results</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Using </span><span class="si">%s</span><span class="s2"> covariance requires using patches.&quot;</span><span class="o">%</span><span class="n">name</span><span class="p">)</span>
    <span class="n">npatch</span> <span class="o">=</span> <span class="n">corrs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_get_npatch</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">corrs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">_get_npatch</span><span class="p">()</span> <span class="o">!=</span> <span class="n">npatch</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;All correlations must use the same number of patches&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">npatch</span>

<span class="k">def</span> <span class="nf">_cov_jackknife</span><span class="p">(</span><span class="n">corrs</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
    <span class="c1"># Calculate the jackknife covariance for the given statistics</span>

    <span class="c1"># The basic jackknife formula is:</span>
    <span class="c1"># C = (1-1/npatch) Sum_i (v_i - v_mean) (v_i - v_mean)^T</span>
    <span class="c1"># where v_i is the vector when excluding patch i, and v_mean is the mean of all {v_i}.</span>
    <span class="c1">#   v_i = Sum_jk!=i num_jk / Sum_jk!=i denom_jk</span>

    <span class="n">npatch</span> <span class="o">=</span> <span class="n">_check_patch_nums</span><span class="p">(</span><span class="n">corrs</span><span class="p">,</span> <span class="s1">&#39;jackknife&#39;</span><span class="p">)</span>

    <span class="n">plist</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">_jackknife_pairs</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">corrs</span><span class="p">]</span>
    <span class="c1"># Swap order of plist.  Right now it&#39;s a list for each corr of a list for each row.</span>
    <span class="c1"># We want a list by row with a list for each corr.</span>
    <span class="n">plist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">plist</span><span class="p">))</span>

    <span class="n">v</span><span class="p">,</span><span class="n">w</span> <span class="o">=</span> <span class="n">_make_cov_design_matrix</span><span class="p">(</span><span class="n">corrs</span><span class="p">,</span> <span class="n">plist</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="s1">&#39;jackknife&#39;</span><span class="p">)</span>
    <span class="n">vmean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">-=</span> <span class="n">vmean</span>
    <span class="n">C</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="mf">1.</span><span class="o">/</span><span class="n">npatch</span><span class="p">)</span> <span class="o">*</span> <span class="n">v</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">C</span>

<span class="k">def</span> <span class="nf">_cov_sample</span><span class="p">(</span><span class="n">corrs</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
    <span class="c1"># Calculate the sample covariance.</span>

    <span class="c1"># This is kind of the converse of the jackknife.  We take each patch and use any</span>
    <span class="c1"># correlations of it with any other patch.  The sample variance of these is the estimate</span>
    <span class="c1"># of the overall variance.</span>

    <span class="c1"># C = 1/(npatch-1) Sum_i w_i (v_i - v_mean) (v_i - v_mean)^T</span>
    <span class="c1"># where v_i = Sum_j num_ij / Sum_j denom_ij</span>
    <span class="c1"># and w_i is the fraction of the total weight in each patch</span>

    <span class="n">npatch</span> <span class="o">=</span> <span class="n">_check_patch_nums</span><span class="p">(</span><span class="n">corrs</span><span class="p">,</span> <span class="s1">&#39;sample&#39;</span><span class="p">)</span>

    <span class="n">plist</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">_sample_pairs</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">corrs</span><span class="p">]</span>
    <span class="c1"># Swap order of plist.  Right now it&#39;s a list for each corr of a list for each row.</span>
    <span class="c1"># We want a list by row with a list for each corr.</span>
    <span class="n">plist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">plist</span><span class="p">))</span>

    <span class="n">v</span><span class="p">,</span><span class="n">w</span> <span class="o">=</span> <span class="n">_make_cov_design_matrix</span><span class="p">(</span><span class="n">corrs</span><span class="p">,</span> <span class="n">plist</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="s1">&#39;sample&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">w</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Cannot compute sample variance when some patches have no data.&quot;</span><span class="p">)</span>

    <span class="n">w</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>  <span class="c1"># Now w is the fractional weight for each patch</span>

    <span class="n">vmean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">-=</span> <span class="n">vmean</span>
    <span class="n">C</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">npatch</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="n">v</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">C</span>

<span class="k">def</span> <span class="nf">_cov_marked</span><span class="p">(</span><span class="n">corrs</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
    <span class="c1"># Calculate the marked-point bootstrap covariance</span>

    <span class="c1"># This is based on the article A Valid and Fast Spatial Bootstrap for Correlation Functions</span>
    <span class="c1"># by Ji Meng Loh, 2008, cf. https://ui.adsabs.harvard.edu/abs/2008ApJ...681..726L/abstract</span>

    <span class="c1"># We do a bootstrap sampling of the patches.  For each patch selected, we include</span>
    <span class="c1"># all pairs that have the sampled patch in the first position.  In the Loh prescription,</span>
    <span class="c1"># the sums of pairs with a given choice of first patch would be the marks.  Here, we</span>
    <span class="c1"># don&#39;t quite do that, since the marks would involve a ratio, so the division is biased</span>
    <span class="c1"># when somewhat noisy.  Rather, we sum the numerators and denominators of the marks</span>
    <span class="c1"># separately and divide the sums.</span>

    <span class="c1"># From the bootstrap totals, v_i, the estimated covariance matrix is</span>

    <span class="c1"># C = 1/(nboot) Sum_i (v_i - v_mean) (v_i - v_mean)^T</span>

    <span class="n">npatch</span> <span class="o">=</span> <span class="n">_check_patch_nums</span><span class="p">(</span><span class="n">corrs</span><span class="p">,</span> <span class="s1">&#39;marked_bootstrap&#39;</span><span class="p">)</span>

    <span class="n">nboot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">c</span><span class="o">.</span><span class="n">num_bootstrap</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">corrs</span><span class="p">])</span>  <span class="c1"># use the maximum if they differ.</span>

    <span class="n">plist</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nboot</span><span class="p">):</span>
        <span class="c1"># Select a random set of indices to use.  (Will have repeats.)</span>
        <span class="n">indx</span> <span class="o">=</span> <span class="n">corrs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">rng</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">npatch</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">npatch</span><span class="p">)</span>
        <span class="n">vpairs</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">_marked_pairs</span><span class="p">(</span><span class="n">indx</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">corrs</span><span class="p">]</span>
        <span class="n">plist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vpairs</span><span class="p">)</span>

    <span class="n">v</span><span class="p">,</span><span class="n">w</span> <span class="o">=</span> <span class="n">_make_cov_design_matrix</span><span class="p">(</span><span class="n">corrs</span><span class="p">,</span> <span class="n">plist</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="s1">&#39;marked_bootstrap&#39;</span><span class="p">)</span>
    <span class="n">vmean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">-=</span> <span class="n">vmean</span>
    <span class="n">C</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">nboot</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">v</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">C</span>

<span class="k">def</span> <span class="nf">_cov_bootstrap</span><span class="p">(</span><span class="n">corrs</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
    <span class="c1"># Calculate the 2-patch bootstrap covariance estimate.</span>

    <span class="c1"># This is a different version of the bootstrap idea.  It selects patches at random with</span>
    <span class="c1"># replacement, and then generates the statistic using all the auto-correlations at their</span>
    <span class="c1"># selected repetition plus all the cross terms, which aren&#39;t actually auto terms.</span>
    <span class="c1"># It seems to do a slightly better job than the marked-point bootstrap above from the</span>
    <span class="c1"># tests done in the test suite.  But the difference is generally pretty small.</span>

    <span class="n">npatch</span> <span class="o">=</span> <span class="n">_check_patch_nums</span><span class="p">(</span><span class="n">corrs</span><span class="p">,</span> <span class="s1">&#39;bootstrap&#39;</span><span class="p">)</span>

    <span class="n">nboot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">c</span><span class="o">.</span><span class="n">num_bootstrap</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">corrs</span><span class="p">])</span>  <span class="c1"># use the maximum if they differ.</span>

    <span class="n">plist</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nboot</span><span class="p">):</span>
        <span class="n">indx</span> <span class="o">=</span> <span class="n">corrs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">rng</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">npatch</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">npatch</span><span class="p">)</span>
        <span class="n">vpairs</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">_bootstrap_pairs</span><span class="p">(</span><span class="n">indx</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">corrs</span><span class="p">]</span>
        <span class="n">plist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vpairs</span><span class="p">)</span>

    <span class="n">v</span><span class="p">,</span><span class="n">w</span> <span class="o">=</span> <span class="n">_make_cov_design_matrix</span><span class="p">(</span><span class="n">corrs</span><span class="p">,</span> <span class="n">plist</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="s1">&#39;bootstrap&#39;</span><span class="p">)</span>
    <span class="n">vmean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">-=</span> <span class="n">vmean</span>
    <span class="n">C</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">nboot</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">v</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">C</span>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2019, Mike Jarvis.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>