<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>treecorr.corr2base &mdash; TreeCorr 5.0.1 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            TreeCorr
          </a>
              <div class="version">
                5.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../catalog.html">Input Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../correlation2.html">Two-point Correlation Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../correlation3.html">Three-point Correlation Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../metric.html">Metrics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../binning.html">Binning</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../shear.html">Shear Conventions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../patches.html">Patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cov.html">Covariance Estimates</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../field.html">Fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../scripts.html">Using configuration files</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../guide.html">Getting Started Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../changes.html">Changes from version 4.3 to 5.0</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../history.html">Previous History</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">TreeCorr</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">treecorr.corr2base</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for treecorr.corr2base</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (c) 2003-2024 by Mike Jarvis</span>
<span class="c1">#</span>
<span class="c1"># TreeCorr is free software: redistribution and use in source and binary forms,</span>
<span class="c1"># with or without modification, are permitted provided that the following</span>
<span class="c1"># conditions are met:</span>
<span class="c1">#</span>
<span class="c1"># 1. Redistributions of source code must retain the above copyright notice, this</span>
<span class="c1">#    list of conditions, and the disclaimer given in the accompanying LICENSE</span>
<span class="c1">#    file.</span>
<span class="c1"># 2. Redistributions in binary form must reproduce the above copyright notice,</span>
<span class="c1">#    this list of conditions, and the disclaimer given in the documentation</span>
<span class="c1">#    and/or other materials provided with the distribution.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">.. module:: corr2base</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">coord</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">collections</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">_treecorr</span>
<span class="kn">from</span> <span class="nn">.config</span> <span class="kn">import</span> <span class="n">merge_config</span><span class="p">,</span> <span class="n">setup_logger</span><span class="p">,</span> <span class="n">get</span><span class="p">,</span> <span class="n">make_minimal_config</span>
<span class="kn">from</span> <span class="nn">.util</span> <span class="kn">import</span> <span class="n">parse_metric</span><span class="p">,</span> <span class="n">metric_enum</span><span class="p">,</span> <span class="n">coord_enum</span><span class="p">,</span> <span class="n">set_omp_threads</span><span class="p">,</span> <span class="n">lazy_property</span>
<span class="kn">from</span> <span class="nn">.util</span> <span class="kn">import</span> <span class="n">make_reader</span>
<span class="kn">from</span> <span class="nn">.catalog</span> <span class="kn">import</span> <span class="n">Catalog</span>

<span class="k">class</span> <span class="nc">Namespace</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">pass</span>

<div class="viewcode-block" id="Corr2"><a class="viewcode-back" href="../../correlation2.html#treecorr.Corr2">[docs]</a><span class="k">class</span> <span class="nc">Corr2</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This class stores the results of a 2-point correlation calculation, along with some</span>
<span class="sd">    ancillary data.</span>

<span class="sd">    This is a base class that is not intended to be constructed directly.  But it has a few</span>
<span class="sd">    helper functions that derived classes can use to help perform their calculations.  See</span>
<span class="sd">    the derived classes for more details:</span>

<span class="sd">    - `NNCorrelation` handles count-count correlation functions</span>
<span class="sd">    - `NKCorrelation` handles count-scalar correlation functions</span>
<span class="sd">    - `KKCorrelation` handles scalar-scalar correlation functions</span>
<span class="sd">    - `NZCorrelation` handles count-complex correlation functions</span>
<span class="sd">    - `KZCorrelation` handles scalar-complex correlation functions</span>
<span class="sd">    - `ZZCorrelation` handles complex-complex correlation functions</span>
<span class="sd">    - `NVCorrelation` handles count-vector correlation functions</span>
<span class="sd">    - `KVCorrelation` handles scalar-vector correlation functions</span>
<span class="sd">    - `VVCorrelation` handles vector-vector correlation functions</span>
<span class="sd">    - `NGCorrelation` handles count-shear correlation functions</span>
<span class="sd">    - `KGCorrelation` handles scalar-shear correlation functions</span>
<span class="sd">    - `GGCorrelation` handles shear-shear correlation functions</span>
<span class="sd">    - `NTCorrelation` handles count-trefoil correlation functions</span>
<span class="sd">    - `KTCorrelation` handles scalar-trefoil correlation functions</span>
<span class="sd">    - `TTCorrelation` handles trefoil-trefoil correlation functions</span>
<span class="sd">    - `NQCorrelation` handles count-quatrefoil correlation functions</span>
<span class="sd">    - `KQCorrelation` handles scalar-quatrefoil correlation functions</span>
<span class="sd">    - `QQCorrelation` handles quatrefoil-quatrefoil correlation functions</span>

<span class="sd">    .. note::</span>

<span class="sd">        TreeCorr was originally designed for weak lensing applications, so the K letter for</span>
<span class="sd">        scalar quantities nominally refers to the weak lesing kappa field.</span>
<span class="sd">        But in fact any scalar quantity may be used here.</span>
<span class="sd">        (CMB temperature fluctuations for example.)</span>

<span class="sd">    The constructor for all derived classes take a config dict as the first argument,</span>
<span class="sd">    since this is often how we keep track of parameters, but if you don&#39;t want to</span>
<span class="sd">    use one or if you want to change some parameters from what are in a config dict,</span>
<span class="sd">    then you can use normal kwargs, which take precedence over anything in the config dict.</span>

<span class="sd">    There are a number of possible definitions for the distance between two points, which</span>
<span class="sd">    are appropriate for different use cases.  These are specified by the ``metric`` parameter.</span>
<span class="sd">    The possible options are:</span>

<span class="sd">        - &#39;Euclidean&#39; = straight line Euclidean distance between two points.</span>
<span class="sd">        - &#39;FisherRperp&#39; = the perpendicular component of the distance, following the</span>
<span class="sd">          definitions in Fisher et al, 1994 (MNRAS, 267, 927).</span>
<span class="sd">        - &#39;OldRperp&#39; = the perpendicular component of the distance using the definition</span>
<span class="sd">          of Rperp from TreeCorr v3.x.</span>
<span class="sd">        - &#39;Rperp&#39; = an alias for FisherRperp.  You can change it to be an alias for</span>
<span class="sd">          OldRperp if you want by setting ``treecorr.Rperp_alias = &#39;OldRperp&#39;`` before</span>
<span class="sd">          using it.</span>
<span class="sd">        - &#39;Rlens&#39; = the distance from the first object (taken to be a lens) to the line</span>
<span class="sd">          connecting Earth and the second object (taken to be a lensed source).</span>
<span class="sd">        - &#39;Arc&#39; = the true great circle distance for spherical coordinates.</span>
<span class="sd">        - &#39;Periodic&#39; = Like Euclidean, but with periodic boundaries.</span>

<span class="sd">    See `Metrics` for more information about these various metric options.</span>

<span class="sd">    There are also a few different possibile binning prescriptions to define the range of</span>
<span class="sd">    distances, which should be placed into each bin.</span>

<span class="sd">        - &#39;Log&#39; - logarithmic binning in the distance.  The bin steps will be uniform in</span>
<span class="sd">          log(r) from log(min_sep) .. log(max_sep).</span>
<span class="sd">        - &#39;Linear&#39; - linear binning in the distance.  The bin steps will be uniform in r</span>
<span class="sd">          from min_sep .. max_sep.</span>
<span class="sd">        - &#39;TwoD&#39; = 2-dimensional binning from x = (-max_sep .. max_sep) and</span>
<span class="sd">          y = (-max_sep .. max_sep).  The bin steps will be uniform in both x and y.</span>
<span class="sd">          (i.e. linear in x,y)</span>

<span class="sd">    See `Binning` for more information about the different binning options.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        config (dict):      A configuration dict that can be used to pass in the below kwargs if</span>
<span class="sd">                            desired.  This dict is allowed to have addition entries in addition</span>
<span class="sd">                            to those listed below, which are ignored here. (default: None)</span>
<span class="sd">        logger:             If desired, a logger object for logging. (default: None, in which case</span>
<span class="sd">                            one will be built according to the config dict&#39;s verbose level.)</span>

<span class="sd">    Keyword Arguments:</span>

<span class="sd">        nbins (int):        How many bins to use. (Exactly three of nbins, bin_size, min_sep,</span>
<span class="sd">                            max_sep are required. If nbins is not given or set to None, it will be</span>
<span class="sd">                            calculated from the values of the other three, rounding up to the next</span>
<span class="sd">                            highest integer. In this case, bin_size will be readjusted to account</span>
<span class="sd">                            for this rounding up.)</span>
<span class="sd">        bin_size (float):   The width of the bins in log(separation). (Exactly three of nbins,</span>
<span class="sd">                            bin_size, min_sep, max_sep are required.  If bin_size is not given or</span>
<span class="sd">                            set to None, it will be calculated from the values of the other three.)</span>
<span class="sd">        min_sep (float):    The minimum separation in units of sep_units, if relevant. (Exactly</span>
<span class="sd">                            three of nbins, bin_size, min_sep, max_sep are required.  If min_sep is</span>
<span class="sd">                            not given or set to None, it will be calculated from the values of the</span>
<span class="sd">                            other three.)</span>
<span class="sd">        max_sep (float):    The maximum separation in units of sep_units, if relevant. (Exactly</span>
<span class="sd">                            three of nbins, bin_size, min_sep, max_sep are required.  If max_sep is</span>
<span class="sd">                            not given or set to None, it will be calculated from the values of the</span>
<span class="sd">                            other three.)</span>

<span class="sd">        sep_units (str):    The units to use for the separation values, given as a string.  This</span>
<span class="sd">                            includes both min_sep and max_sep above, as well as the units of the</span>
<span class="sd">                            output distance values.  Valid options are arcsec, arcmin, degrees,</span>
<span class="sd">                            hours, radians.  (default: radians if angular units make sense, but for</span>
<span class="sd">                            3-d or flat 2-d positions, the default will just match the units of</span>
<span class="sd">                            x,y[,z] coordinates)</span>
<span class="sd">        bin_slop (float):   How much slop to allow in the placement of pairs in the bins.</span>
<span class="sd">                            If bin_slop = 1, then the bin into which a particular pair is placed</span>
<span class="sd">                            may be incorrect by at most 1.0 bin widths.  (default: None, which</span>
<span class="sd">                            means to use a bin_slop that gives a maximum error of 10% on any bin,</span>
<span class="sd">                            which has been found to yield good results for most application.</span>
<span class="sd">        angle_slop (float): How much slop to allow in the angular direction. This works very</span>
<span class="sd">                            similarly to bin_slop, but applies to the projection angle of a pair</span>
<span class="sd">                            of cells. The projection angle for any two objects in a pair of cells</span>
<span class="sd">                            will differ by no more than angle_slop radians from the projection</span>
<span class="sd">                            angle defined by the centers of the cells. (default: 0.1)</span>
<span class="sd">        brute (bool):       Whether to use the &quot;brute force&quot; algorithm.  (default: False) Options</span>
<span class="sd">                            are:</span>

<span class="sd">                             - False (the default): Stop at non-leaf cells whenever the error in</span>
<span class="sd">                               the separation is compatible with the given bin_slop and angle_slop.</span>
<span class="sd">                             - True: Go to the leaves for both catalogs.</span>
<span class="sd">                             - 1: Always go to the leaves for cat1, but stop at non-leaf cells of</span>
<span class="sd">                               cat2 when the error is compatible with the given slop values.</span>
<span class="sd">                             - 2: Always go to the leaves for cat2, but stop at non-leaf cells of</span>
<span class="sd">                               cat1 when the error is compatible with the given slop values.</span>

<span class="sd">        verbose (int):      If no logger is provided, this will optionally specify a logging level</span>
<span class="sd">                            to use:</span>

<span class="sd">                             - 0 means no logging output</span>
<span class="sd">                             - 1 means to output warnings only (default)</span>
<span class="sd">                             - 2 means to output various progress information</span>
<span class="sd">                             - 3 means to output extensive debugging information</span>

<span class="sd">        log_file (str):     If no logger is provided, this will specify a file to write the logging</span>
<span class="sd">                            output.  (default: None; i.e. output to standard output)</span>
<span class="sd">        output_dots (bool): Whether to output progress dots during the calcualtion of the</span>
<span class="sd">                            correlation function. (default: False unless verbose is given and &gt;= 2,</span>
<span class="sd">                            in which case True)</span>

<span class="sd">        split_method (str): How to split the cells in the tree when building the tree structure.</span>
<span class="sd">                            Options are:</span>

<span class="sd">                            - mean = Use the arithmetic mean of the coordinate being split.</span>
<span class="sd">                              (default)</span>
<span class="sd">                            - median = Use the median of the coordinate being split.</span>
<span class="sd">                            - middle = Use the middle of the range; i.e. the average of the minimum</span>
<span class="sd">                              and maximum value.</span>
<span class="sd">                            - random: Use a random point somewhere in the middle two quartiles of</span>
<span class="sd">                              the range.</span>

<span class="sd">        min_top (int):      The minimum number of top layers to use when setting up the field.</span>
<span class="sd">                            (default: :math:`\\max(3, \\log_2(N_{\\rm cpu}))`)</span>
<span class="sd">        max_top (int):      The maximum number of top layers to use when setting up the field.</span>
<span class="sd">                            The top-level cells are where each calculation job starts. There will</span>
<span class="sd">                            typically be of order :math:`2^{\\rm max\\_top}` top-level cells.</span>
<span class="sd">                            (default: 10)</span>
<span class="sd">        precision (int):    The precision to use for the output values. This specifies how many</span>
<span class="sd">                            digits to write. (default: 4)</span>
<span class="sd">        m2_uform (str):     The default functional form to use for aperture mass calculations.</span>
<span class="sd">                            see `calculateMapSq` for more details.  (default: &#39;Crittenden&#39;)</span>

<span class="sd">        metric (str):       Which metric to use for distance measurements.  Options are listed</span>
<span class="sd">                            above.  (default: &#39;Euclidean&#39;)</span>
<span class="sd">        bin_type (str):     What type of binning should be used.  Options are listed above.</span>
<span class="sd">                            (default: &#39;Log&#39;)</span>
<span class="sd">        min_rpar (float):   The minimum difference in Rparallel to allow for pairs being included</span>
<span class="sd">                            in the correlation function.  (default: None)</span>
<span class="sd">        max_rpar (float):   The maximum difference in Rparallel to allow for pairs being included</span>
<span class="sd">                            in the correlation function.  (default: None)</span>
<span class="sd">        period (float):     For the &#39;Periodic&#39; metric, the period to use in all directions.</span>
<span class="sd">                            (default: None)</span>
<span class="sd">        xperiod (float):    For the &#39;Periodic&#39; metric, the period to use in the x direction.</span>
<span class="sd">                            (default: period)</span>
<span class="sd">        yperiod (float):    For the &#39;Periodic&#39; metric, the period to use in the y direction.</span>
<span class="sd">                            (default: period)</span>
<span class="sd">        zperiod (float):    For the &#39;Periodic&#39; metric, the period to use in the z direction.</span>
<span class="sd">                            (default: period)</span>

<span class="sd">        var_method (str):   Which method to use for estimating the variance. Options are:</span>
<span class="sd">                            &#39;shot&#39;, &#39;jackknife&#39;, &#39;sample&#39;, &#39;bootstrap&#39;, &#39;marked_bootstrap&#39;.</span>
<span class="sd">                            (default: &#39;shot&#39;)</span>
<span class="sd">        num_bootstrap (int): How many bootstrap samples to use for the &#39;bootstrap&#39; and</span>
<span class="sd">                            &#39;marked_bootstrap&#39; var_methods.  (default: 500)</span>
<span class="sd">        rng (RandomState):  If desired, a numpy.random.RandomState instance to use for bootstrap</span>
<span class="sd">                            random number generation. (default: None)</span>

<span class="sd">        num_threads (int):  How many OpenMP threads to use during the calculation.</span>
<span class="sd">                            (default: use the number of cpu cores)</span>

<span class="sd">                            .. note::</span>

<span class="sd">                                This won&#39;t work if the system&#39;s C compiler cannot use OpenMP</span>
<span class="sd">                                (e.g. clang prior to version 3.7.)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># This is appropriate for anything where angles matter, but for pure scalars (NN, NK, KK),</span>
    <span class="c1"># this is unnecessary, so we override it in those classes.</span>
    <span class="n">_default_angle_slop</span> <span class="o">=</span> <span class="mf">0.1</span>

    <span class="c1"># A dict pointing from _letters to cls.  E.g. _lookup_dict[&#39;GG&#39;] = GGCorrelation</span>
    <span class="n">_lookup_dict</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="n">_valid_params</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;nbins&#39;</span> <span class="p">:</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;The number of output bins to use.&#39;</span><span class="p">),</span>
        <span class="s1">&#39;bin_size&#39;</span> <span class="p">:</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;The size of the output bins in log(sep).&#39;</span><span class="p">),</span>
        <span class="s1">&#39;min_sep&#39;</span> <span class="p">:</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;The minimum separation to include in the output.&#39;</span><span class="p">),</span>
        <span class="s1">&#39;max_sep&#39;</span> <span class="p">:</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;The maximum separation to include in the output.&#39;</span><span class="p">),</span>
        <span class="s1">&#39;sep_units&#39;</span> <span class="p">:</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">coord</span><span class="o">.</span><span class="n">AngleUnit</span><span class="o">.</span><span class="n">valid_names</span><span class="p">,</span>
                <span class="s1">&#39;The units to use for min_sep and max_sep.  &#39;</span>
                <span class="s1">&#39;Also the units of the output distances&#39;</span><span class="p">),</span>
        <span class="s1">&#39;bin_slop&#39;</span> <span class="p">:</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;The fraction of a bin width by which it is ok to let the pairs miss the correct &#39;</span>
                <span class="s1">&#39;bin.&#39;</span><span class="p">,</span>
                <span class="s1">&#39;The default is to use 1 if bin_size &lt;= 0.1, or 0.1/bin_size if bin_size &gt; 0.1.&#39;</span><span class="p">),</span>
        <span class="s1">&#39;angle_slop&#39;</span> <span class="p">:</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;The maximum difference in the projection angle for any pair of objects relative &#39;</span>
                <span class="s1">&#39;to that of the pair of cells being accumulated into bins&#39;</span><span class="p">),</span>
        <span class="s1">&#39;brute&#39;</span> <span class="p">:</span> <span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
                <span class="s1">&#39;Whether to use brute-force algorithm&#39;</span><span class="p">),</span>
        <span class="s1">&#39;verbose&#39;</span> <span class="p">:</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
                <span class="s1">&#39;How verbose the code should be during processing. &#39;</span><span class="p">,</span>
                <span class="s1">&#39;0 = Errors Only, 1 = Warnings, 2 = Progress, 3 = Debugging&#39;</span><span class="p">),</span>
        <span class="s1">&#39;log_file&#39;</span> <span class="p">:</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;If desired, an output file for the logging output.&#39;</span><span class="p">,</span>
                <span class="s1">&#39;The default is to write the output to stdout.&#39;</span><span class="p">),</span>
        <span class="s1">&#39;output_dots&#39;</span> <span class="p">:</span> <span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;Whether to output dots to the stdout during the C++-level computation.&#39;</span><span class="p">,</span>
                <span class="s1">&#39;The default is True if verbose &gt;= 2 and there is no log_file.  Else False.&#39;</span><span class="p">),</span>
        <span class="s1">&#39;split_method&#39;</span> <span class="p">:</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="s1">&#39;median&#39;</span><span class="p">,</span> <span class="s1">&#39;middle&#39;</span><span class="p">,</span> <span class="s1">&#39;random&#39;</span><span class="p">],</span>
                <span class="s1">&#39;Which method to use for splitting cells.&#39;</span><span class="p">),</span>
        <span class="s1">&#39;min_top&#39;</span> <span class="p">:</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;The minimum number of top layers to use when setting up the field.&#39;</span><span class="p">),</span>
        <span class="s1">&#39;max_top&#39;</span> <span class="p">:</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;The maximum number of top layers to use when setting up the field.&#39;</span><span class="p">),</span>
        <span class="s1">&#39;precision&#39;</span> <span class="p">:</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;The number of digits after the decimal in the output.&#39;</span><span class="p">),</span>
        <span class="s1">&#39;m2_uform&#39;</span> <span class="p">:</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;Crittenden&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;Crittenden&#39;</span><span class="p">,</span> <span class="s1">&#39;Schneider&#39;</span><span class="p">],</span>
                <span class="s1">&#39;The function form of the mass aperture.&#39;</span><span class="p">),</span>
        <span class="s1">&#39;metric&#39;</span><span class="p">:</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;Euclidean&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;Euclidean&#39;</span><span class="p">,</span> <span class="s1">&#39;Rperp&#39;</span><span class="p">,</span> <span class="s1">&#39;FisherRperp&#39;</span><span class="p">,</span> <span class="s1">&#39;OldRperp&#39;</span><span class="p">,</span>
                                             <span class="s1">&#39;Rlens&#39;</span><span class="p">,</span> <span class="s1">&#39;Arc&#39;</span><span class="p">,</span> <span class="s1">&#39;Periodic&#39;</span><span class="p">],</span>
                <span class="s1">&#39;Which metric to use for the distance measurements&#39;</span><span class="p">),</span>
        <span class="s1">&#39;bin_type&#39;</span><span class="p">:</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;Log&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;Log&#39;</span><span class="p">,</span> <span class="s1">&#39;Linear&#39;</span><span class="p">,</span> <span class="s1">&#39;TwoD&#39;</span><span class="p">],</span>
                <span class="s1">&#39;Which type of binning should be used&#39;</span><span class="p">),</span>
        <span class="s1">&#39;min_rpar&#39;</span><span class="p">:</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;The minimum difference in Rparallel for pairs to include&#39;</span><span class="p">),</span>
        <span class="s1">&#39;max_rpar&#39;</span><span class="p">:</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;The maximum difference in Rparallel for pairs to include&#39;</span><span class="p">),</span>
        <span class="s1">&#39;period&#39;</span><span class="p">:</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;The period to use for all directions for the Periodic metric&#39;</span><span class="p">),</span>
        <span class="s1">&#39;xperiod&#39;</span><span class="p">:</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;The period to use for the x direction for the Periodic metric&#39;</span><span class="p">),</span>
        <span class="s1">&#39;yperiod&#39;</span><span class="p">:</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;The period to use for the y direction for the Periodic metric&#39;</span><span class="p">),</span>
        <span class="s1">&#39;zperiod&#39;</span><span class="p">:</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;The period to use for the z direction for the Periodic metric&#39;</span><span class="p">),</span>

        <span class="s1">&#39;var_method&#39;</span><span class="p">:</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;shot&#39;</span><span class="p">,</span>
                <span class="p">[</span><span class="s1">&#39;shot&#39;</span><span class="p">,</span> <span class="s1">&#39;jackknife&#39;</span><span class="p">,</span> <span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;bootstrap&#39;</span><span class="p">,</span> <span class="s1">&#39;marked_bootstrap&#39;</span><span class="p">],</span>
                <span class="s1">&#39;The method to use for estimating the variance&#39;</span><span class="p">),</span>
        <span class="s1">&#39;num_bootstrap&#39;</span><span class="p">:</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;How many bootstrap samples to use for the var_method=bootstrap and &#39;</span>
                <span class="s1">&#39;marked_bootstrap&#39;</span><span class="p">),</span>
        <span class="s1">&#39;num_threads&#39;</span> <span class="p">:</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;How many threads should be used. num_threads &lt;= 0 means auto based on num cores.&#39;</span><span class="p">),</span>
    <span class="p">}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">config</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_corr</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Do this first to make sure we always have it for __del__</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">config</span> <span class="o">=</span> <span class="n">merge_config</span><span class="p">(</span><span class="n">config</span><span class="p">,</span><span class="n">kwargs</span><span class="p">,</span><span class="n">Corr2</span><span class="o">.</span><span class="n">_valid_params</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">logger</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_logger_name</span> <span class="o">=</span> <span class="s1">&#39;treecorr.Corr2&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">setup_logger</span><span class="p">(</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">,</span><span class="s1">&#39;verbose&#39;</span><span class="p">,</span><span class="nb">int</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;log_file&#39;</span><span class="p">,</span><span class="kc">None</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_logger_name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logger</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_logger_name</span> <span class="o">=</span> <span class="n">logger</span><span class="o">.</span><span class="n">name</span>

        <span class="c1"># We&#39;ll make a bunch of attributes here, which we put into a namespace called _ro.</span>
        <span class="c1"># These are the core attributes that won&#39;t ever be changed after construction.</span>
        <span class="c1"># This is an efficiency optimization (both memory and flops), since it will allow</span>
        <span class="c1"># copy() to just copy a pointer to the _ro namespace without having to copy each</span>
        <span class="c1"># individual attribute separately.</span>
        <span class="c1"># The access of these attributes are all via read-only properties.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span> <span class="o">=</span> <span class="n">Namespace</span><span class="p">()</span>

        <span class="k">if</span> <span class="s1">&#39;output_dots&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">output_dots</span> <span class="o">=</span> <span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">,</span><span class="s1">&#39;output_dots&#39;</span><span class="p">,</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">output_dots</span> <span class="o">=</span> <span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">,</span><span class="s1">&#39;verbose&#39;</span><span class="p">,</span><span class="nb">int</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">bin_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;bin_type&#39;</span><span class="p">,</span> <span class="s1">&#39;Log&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">sep_units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;sep_units&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">_sep_units</span> <span class="o">=</span> <span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">,</span><span class="s1">&#39;sep_units&#39;</span><span class="p">,</span><span class="nb">str</span><span class="p">,</span><span class="s1">&#39;radians&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">_log_sep_units</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sep_units</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;nbins&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;max_sep&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Missing required parameter max_sep&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;min_sep&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_type</span> <span class="o">!=</span> <span class="s1">&#39;TwoD&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Missing required parameter min_sep&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;bin_size&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Missing required parameter bin_size&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">min_sep</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;min_sep&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">max_sep</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;max_sep&#39;</span><span class="p">])</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_sep</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_sep</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;max_sep must be larger than min_sep&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">bin_size</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;bin_size&#39;</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">nbins</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;bin_size&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;max_sep&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Missing required parameter max_sep&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;min_sep&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_type</span> <span class="o">!=</span> <span class="s1">&#39;TwoD&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Missing required parameter min_sep&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">min_sep</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;min_sep&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">max_sep</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;max_sep&#39;</span><span class="p">])</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_sep</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_sep</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;max_sep must be larger than min_sep&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">nbins</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;nbins&#39;</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">bin_size</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;max_sep&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;min_sep&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_type</span> <span class="o">!=</span> <span class="s1">&#39;TwoD&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Missing required parameter min_sep&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">min_sep</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;min_sep&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">nbins</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;nbins&#39;</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">bin_size</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;bin_size&#39;</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">max_sep</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_type</span> <span class="o">==</span> <span class="s1">&#39;TwoD&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Only 2 of max_sep, bin_size, nbins are allowed &quot;</span>
                                <span class="s2">&quot;for bin_type=&#39;TwoD&#39;.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;min_sep&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Only 3 of min_sep, max_sep, bin_size, nbins are allowed.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">max_sep</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;max_sep&#39;</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">nbins</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;nbins&#39;</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">bin_size</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;bin_size&#39;</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">min_sep</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_type</span> <span class="o">==</span> <span class="s1">&#39;Log&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbins</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">nbins</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_sep</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">min_sep</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span><span class="p">))</span>
                <span class="c1"># Update bin_size given this value of nbins</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">bin_size</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_sep</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">min_sep</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">nbins</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">bin_size</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_sep</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">min_sep</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">nbins</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_sep</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">max_sep</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbins</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">min_sep</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">min_sep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_sep</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">nbins</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span><span class="p">)</span>

            <span class="c1"># This makes nbins evenly spaced entries in log(r) starting with 0 with step bin_size</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">logr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbins</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbins</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                          <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="c1"># Offset by the position of the center of the first bin.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">logr</span> <span class="o">+=</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_sep</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">rnom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logr</span><span class="p">)</span>
            <span class="n">half_bin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">left_edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rnom</span> <span class="o">/</span> <span class="n">half_bin</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">right_edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rnom</span> <span class="o">*</span> <span class="n">half_bin</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">_nbins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbins</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">_bintype</span> <span class="o">=</span> <span class="n">_treecorr</span><span class="o">.</span><span class="n">Log</span>
            <span class="n">max_good_slop</span> <span class="o">=</span> <span class="mf">0.1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_type</span> <span class="o">==</span> <span class="s1">&#39;Linear&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbins</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">nbins</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">max_sep</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">min_sep</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span><span class="p">))</span>
                <span class="c1"># Update bin_size given this value of nbins</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">bin_size</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_sep</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">min_sep</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">nbins</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">bin_size</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_sep</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">min_sep</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">nbins</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_sep</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">max_sep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_sep</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbins</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">min_sep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_sep</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbins</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">rnom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_sep</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_sep</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbins</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                          <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="c1"># Offset by the position of the center of the first bin.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">rnom</span> <span class="o">+=</span> <span class="mf">0.5</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">left_edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rnom</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">right_edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rnom</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">logr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rnom</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">_nbins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbins</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">_bintype</span> <span class="o">=</span> <span class="n">_treecorr</span><span class="o">.</span><span class="n">Linear</span>
            <span class="c1"># max dr/r = 0.1,</span>
            <span class="c1"># dr = bin_slop * bin_size</span>
            <span class="c1"># min r = min_sep</span>
            <span class="n">max_good_slop</span> <span class="o">=</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_sep</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_type</span> <span class="o">==</span> <span class="s1">&#39;TwoD&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbins</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">nbins</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">max_sep</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">bin_size</span> <span class="o">=</span> <span class="mf">2.</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">max_sep</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">nbins</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">bin_size</span> <span class="o">=</span> <span class="mf">2.</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">max_sep</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">nbins</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">max_sep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbins</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span> <span class="o">/</span> <span class="mf">2.</span>

            <span class="n">sep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">max_sep</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_sep</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbins</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                              <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">sep</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span>
            <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="n">sep</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">dxnom</span> <span class="o">=</span> <span class="n">dx</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">dynom</span> <span class="o">=</span> <span class="n">dy</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">left_edges</span> <span class="o">=</span> <span class="n">dx</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">right_edges</span> <span class="o">=</span> <span class="n">dx</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">bottom_edges</span> <span class="o">=</span> <span class="n">dy</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">top_edges</span> <span class="o">=</span> <span class="n">dy</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">rnom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">dy</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">logr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rnom</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rnom</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">logr</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rnom</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">logr</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">rnom</span><span class="o">==</span><span class="mf">0.</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">_nbins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbins</span><span class="o">**</span><span class="mi">2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">_bintype</span> <span class="o">=</span> <span class="n">_treecorr</span><span class="o">.</span><span class="n">TwoD</span>
            <span class="n">max_good_slop</span> <span class="o">=</span> <span class="mf">0.1</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># pragma: no cover  (Already checked by config layer)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid bin_type </span><span class="si">%s</span><span class="s2">&quot;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_type</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sep_units</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;nbins = </span><span class="si">%d</span><span class="s2">, min,max sep = </span><span class="si">%g</span><span class="s2">..</span><span class="si">%g</span><span class="s2">, bin_size = </span><span class="si">%g</span><span class="s2">&quot;</span><span class="p">,</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">nbins</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_sep</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_sep</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;nbins = </span><span class="si">%d</span><span class="s2">, min,max sep = </span><span class="si">%g</span><span class="s2">..</span><span class="si">%g</span><span class="s2"> </span><span class="si">%s</span><span class="s2">, bin_size = </span><span class="si">%g</span><span class="s2">&quot;</span><span class="p">,</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">nbins</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_sep</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_sep</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sep_units</span><span class="p">,</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span><span class="p">)</span>
        <span class="c1"># The underscore-prefixed names are in natural units (radians for angles)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">_min_sep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_sep</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sep_units</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">_max_sep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_sep</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sep_units</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;Linear&#39;</span><span class="p">,</span> <span class="s1">&#39;TwoD&#39;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">_bin_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sep_units</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">_bin_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">split_method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;split_method&#39;</span><span class="p">,</span><span class="s1">&#39;mean&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Using split_method = </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">split_method</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">min_top</span> <span class="o">=</span> <span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">,</span><span class="s1">&#39;min_top&#39;</span><span class="p">,</span><span class="nb">int</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">max_top</span> <span class="o">=</span> <span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">,</span><span class="s1">&#39;max_top&#39;</span><span class="p">,</span><span class="nb">int</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">bin_slop</span> <span class="o">=</span> <span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">,</span><span class="s1">&#39;bin_slop&#39;</span><span class="p">,</span><span class="nb">float</span><span class="p">,</span><span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">angle_slop</span> <span class="o">=</span> <span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">,</span><span class="s1">&#39;angle_slop&#39;</span><span class="p">,</span><span class="nb">float</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_default_angle_slop</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_slop</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">bin_slop</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">max_good_slop</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_slop</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_slop</span> <span class="o">&gt;</span> <span class="n">max_good_slop</span> <span class="o">+</span> <span class="mf">0.0001</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle_slop</span> <span class="o">&gt;</span> <span class="mf">0.1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Using bin_slop = </span><span class="si">%g</span><span class="s2">, angle_slop = </span><span class="si">%g</span><span class="s2">, bin_size = </span><span class="si">%g</span><span class="s2"> (b = </span><span class="si">%g</span><span class="s2">).</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">bin_slop</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle_slop</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">)</span><span class="o">+</span>
                <span class="s2">&quot;It is recommended to use either bin_slop &lt;= </span><span class="si">%s</span><span class="s2"> &quot;</span><span class="o">%</span><span class="n">max_good_slop</span><span class="o">+</span>
                <span class="s2">&quot;or angle_slop &lt;= 0.1 in this case.&quot;</span><span class="o">+</span>
                <span class="s2">&quot;Larger values of bin_slop/angle_slop may result in significant inaccuracies.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Using bin_slop = </span><span class="si">%g</span><span class="s2">, angle_slop = </span><span class="si">%g</span><span class="s2"> (b = </span><span class="si">%g</span><span class="s2">)&quot;</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bin_slop</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle_slop</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">brute</span> <span class="o">=</span> <span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">,</span><span class="s1">&#39;brute&#39;</span><span class="p">,</span><span class="nb">bool</span><span class="p">,</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">brute</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Doing brute force calculation</span><span class="si">%s</span><span class="s2">.&quot;</span><span class="p">,</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">brute</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="s2">&quot;&quot;</span> <span class="ow">or</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">brute</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="s2">&quot; for first field&quot;</span> <span class="ow">or</span>
                             <span class="s2">&quot; for second field&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coords</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metric</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">min_rpar</span> <span class="o">=</span> <span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">,</span><span class="s1">&#39;min_rpar&#39;</span><span class="p">,</span><span class="nb">float</span><span class="p">,</span><span class="o">-</span><span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="o">.</span><span class="n">max</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">max_rpar</span> <span class="o">=</span> <span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">,</span><span class="s1">&#39;max_rpar&#39;</span><span class="p">,</span><span class="nb">float</span><span class="p">,</span><span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="o">.</span><span class="n">max</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_rpar</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_rpar</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;min_rpar must be &lt;= max_rpar&quot;</span><span class="p">)</span>
        <span class="n">period</span> <span class="o">=</span> <span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">,</span><span class="s1">&#39;period&#39;</span><span class="p">,</span><span class="nb">float</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">xperiod</span> <span class="o">=</span> <span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">,</span><span class="s1">&#39;xperiod&#39;</span><span class="p">,</span><span class="nb">float</span><span class="p">,</span><span class="n">period</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">yperiod</span> <span class="o">=</span> <span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">,</span><span class="s1">&#39;yperiod&#39;</span><span class="p">,</span><span class="nb">float</span><span class="p">,</span><span class="n">period</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">zperiod</span> <span class="o">=</span> <span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">,</span><span class="s1">&#39;zperiod&#39;</span><span class="p">,</span><span class="nb">float</span><span class="p">,</span><span class="n">period</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">var_method</span> <span class="o">=</span> <span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">,</span><span class="s1">&#39;var_method&#39;</span><span class="p">,</span><span class="nb">str</span><span class="p">,</span><span class="s1">&#39;shot&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">num_bootstrap</span> <span class="o">=</span> <span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">,</span><span class="s1">&#39;num_bootstrap&#39;</span><span class="p">,</span><span class="nb">int</span><span class="p">,</span><span class="mi">500</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># for jackknife, etc. store the results of each pair of patches.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">npatch1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch2</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rng</span> <span class="o">=</span> <span class="n">rng</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">meanr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rnom</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meanlogr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rnom</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rnom</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">npairs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rnom</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_varxi</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cov</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_var_num</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_processed_cats1</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_processed_cats2</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">__init_subclass__</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init_subclass__</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s1">&#39;_letters&#39;</span><span class="p">):</span>
            <span class="n">Corr2</span><span class="o">.</span><span class="n">_lookup_dict</span><span class="p">[</span><span class="bp">cls</span><span class="o">.</span><span class="n">_letters</span><span class="p">]</span> <span class="o">=</span> <span class="bp">cls</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rng</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rng</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rng</span>

    <span class="c1"># Properties for all the read-only attributes (&quot;ro&quot; stands for &quot;read-only&quot;)</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">output_dots</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">output_dots</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bin_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">bin_type</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sep_units</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">sep_units</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_sep_units</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">_sep_units</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_log_sep_units</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">_log_sep_units</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">min_sep</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">min_sep</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">max_sep</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">max_sep</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bin_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">bin_size</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nbins</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">nbins</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">logr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">logr</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rnom</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">rnom</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">left_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">left_edges</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">right_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">right_edges</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">top_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">top_edges</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bottom_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">bottom_edges</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dxnom</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">dxnom</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dynom</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">dynom</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_bintype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">_bintype</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_nbins</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">_nbins</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_min_sep</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">_min_sep</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_max_sep</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">_max_sep</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_bin_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">_bin_size</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">split_method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">split_method</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">min_top</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">min_top</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">max_top</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">max_top</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bin_slop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">bin_slop</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">angle_slop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">angle_slop</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">b</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">b</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">brute</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">brute</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">min_rpar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">min_rpar</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">max_rpar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">max_rpar</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">xperiod</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">xperiod</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">yperiod</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">yperiod</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">zperiod</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">zperiod</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">var_method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">var_method</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_bootstrap</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ro</span><span class="o">.</span><span class="n">num_bootstrap</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cov</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The estimated covariance matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cov</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_cov</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">var_method</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cov</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cov</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cov</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cov_diag</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A possibly more efficient way to access just the diagonal of the covariance matrix.</span>

<span class="sd">        If var_method == &#39;shot&#39;, then this won&#39;t make the full covariance matrix, just to</span>
<span class="sd">        then pull out the diagonal.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cov</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_cov</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">var_method</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cov</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cov</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cov</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">corr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_corr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_corr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_builder</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bintype</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_min_sep</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_sep</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nbins</span><span class="p">,</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">_bin_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle_slop</span><span class="p">,</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">min_rpar</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_rpar</span><span class="p">,</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">xperiod</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">yperiod</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">zperiod</span><span class="p">,</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">_xi1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xi2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xi3</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xi4</span><span class="p">,</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">meanr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">meanlogr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npairs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_corr</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return whether two Correlation instances are equal&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nbins</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">nbins</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bin_size</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">bin_size</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">min_sep</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">min_sep</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">max_sep</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">max_sep</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sep_units</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">sep_units</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">coords</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">coords</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bin_type</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">bin_type</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bin_slop</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">bin_slop</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">angle_slop</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">angle_slop</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">min_rpar</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">min_rpar</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">max_rpar</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">max_rpar</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">xperiod</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">xperiod</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">yperiod</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">yperiod</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">zperiod</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">zperiod</span> <span class="ow">and</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meanr</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">meanr</span><span class="p">)</span> <span class="ow">and</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meanlogr</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">meanlogr</span><span class="p">)</span> <span class="ow">and</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">weight</span><span class="p">)</span> <span class="ow">and</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npairs</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">npairs</span><span class="p">)</span> <span class="ow">and</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xi1</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">_xi1</span><span class="p">)</span> <span class="ow">and</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xi2</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">_xi2</span><span class="p">)</span> <span class="ow">and</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xi3</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">_xi3</span><span class="p">)</span> <span class="ow">and</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xi4</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">_xi4</span><span class="p">))</span>

<div class="viewcode-block" id="Corr2.copy"><a class="viewcode-back" href="../../correlation2.html#treecorr.Corr2.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Make a copy&quot;&quot;&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="c1"># Only items that might change need to by deep copied.</span>
                <span class="n">ret</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># For everything else, shallow copy is fine.</span>
                <span class="c1"># In particular don&#39;t deep copy config or logger</span>
                <span class="c1"># Most of the rest are scalars, which copy fine this way.</span>
                <span class="c1"># And the read-only things are all in _ro.</span>
                <span class="c1"># The results dict is trickier.  We rely on it being copied in places, but we</span>
                <span class="c1"># never add more to it after the copy, so shallow copy is fine.</span>
                <span class="n">ret</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">item</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">_corr</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># We&#39;ll want to make a new one of these if we need it.</span>
        <span class="k">return</span> <span class="n">ret</span></div>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">make_minimal_config</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">,</span> <span class="n">Corr2</span><span class="o">.</span><span class="n">_valid_params</span><span class="p">)</span>
        <span class="n">kwargs_str</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s1">=</span><span class="si">{</span><span class="n">v</span><span class="si">!r}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_cls</span><span class="si">}</span><span class="s1">(</span><span class="si">{</span><span class="n">kwargs_str</span><span class="si">}</span><span class="s1">)&#39;</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;_corr&#39;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;_ok&#39;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>     <span class="c1"># Remake this as needed.</span>
        <span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;logger&#39;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>  <span class="c1"># Oh well.  This is just lost in the copy.  Can&#39;t be pickled.</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span> <span class="o">=</span> <span class="n">d</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_corr</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_logger_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">setup_logger</span><span class="p">(</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">,</span><span class="s1">&#39;verbose&#39;</span><span class="p">,</span><span class="nb">int</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;log_file&#39;</span><span class="p">,</span><span class="kc">None</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_logger_name</span><span class="p">)</span>

<div class="viewcode-block" id="Corr2.clear"><a class="viewcode-back" href="../../correlation2.html#treecorr.Corr2.clear">[docs]</a>    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Clear all data vectors, the results dict, and any related values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">npatch1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch2</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;_ok&#39;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nonzero</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return if there are any values accumulated yet.  (i.e. npairs &gt; 0)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npairs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_add_tot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ij</span><span class="p">,</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">):</span>
        <span class="c1"># No op for all but NNCorrelation, which needs to add the tot value</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">_trivially_zero</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">):</span>
        <span class="n">x1</span><span class="p">,</span><span class="n">y1</span><span class="p">,</span><span class="n">z1</span><span class="p">,</span><span class="n">s1</span> <span class="o">=</span> <span class="n">c1</span><span class="o">.</span><span class="n">_get_center_size</span><span class="p">()</span>
        <span class="n">x2</span><span class="p">,</span><span class="n">y2</span><span class="p">,</span><span class="n">z2</span><span class="p">,</span><span class="n">s2</span> <span class="o">=</span> <span class="n">c2</span><span class="o">.</span><span class="n">_get_center_size</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr</span><span class="o">.</span><span class="n">triviallyZero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_metric</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coords</span><span class="p">,</span>
                                       <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">z1</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">z2</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_make_expanded_patch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cat1</span><span class="p">,</span> <span class="n">cat2</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span> <span class="n">low_mem</span><span class="p">):</span>
        <span class="c1"># First figure out the center and size of cat1.</span>
        <span class="n">x1</span><span class="p">,</span><span class="n">y1</span><span class="p">,</span><span class="n">z1</span><span class="p">,</span><span class="n">s1</span> <span class="o">=</span> <span class="n">cat1</span><span class="o">.</span><span class="n">_get_center_size</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coords</span> <span class="o">==</span> <span class="n">_treecorr</span><span class="o">.</span><span class="n">ThreeD</span><span class="p">:</span>
            <span class="c1"># For 3d coords, we collapse everything onto the unit circle, since that&#39;s</span>
            <span class="c1"># what we care about for patch considerations.</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x1</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y1</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">z1</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">r</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># pragma: no branch</span>
                <span class="n">x1</span> <span class="o">/=</span> <span class="n">r</span><span class="p">;</span> <span class="n">y1</span> <span class="o">/=</span> <span class="n">r</span><span class="p">;</span> <span class="n">z1</span> <span class="o">/=</span> <span class="n">r</span>

        <span class="n">cat_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">mask_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">sumw</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">cat2</span><span class="p">:</span>
            <span class="n">sumw</span> <span class="o">+=</span> <span class="n">p</span><span class="o">.</span><span class="n">sumw</span>
            <span class="n">x2</span><span class="p">,</span><span class="n">y2</span><span class="p">,</span><span class="n">z2</span><span class="p">,</span><span class="n">s2</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">_get_center_size</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coords</span> <span class="o">==</span> <span class="n">_treecorr</span><span class="o">.</span><span class="n">ThreeD</span><span class="p">:</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x2</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y2</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">z2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">r</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">x2</span> <span class="o">/=</span> <span class="n">r</span><span class="p">;</span> <span class="n">y2</span> <span class="o">/=</span> <span class="n">r</span><span class="p">;</span> <span class="n">z2</span> <span class="o">/=</span> <span class="n">r</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">x2</span><span class="o">-</span><span class="n">x1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y2</span><span class="o">-</span><span class="n">y1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">z2</span><span class="o">-</span><span class="n">z1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_sep</span> <span class="o">+</span> <span class="n">s1</span> <span class="o">+</span> <span class="n">s2</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">low_mem</span> <span class="ow">and</span> <span class="n">p</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">cat1</span><span class="p">:</span>
                    <span class="n">p</span><span class="o">.</span><span class="n">unload</span><span class="p">()</span>
                <span class="k">continue</span>
            <span class="n">px</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">x</span><span class="p">;</span> <span class="n">py</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">y</span><span class="p">;</span> <span class="n">pz</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">z</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">p</span><span class="o">.</span><span class="n">z</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coords</span> <span class="o">==</span> <span class="n">_treecorr</span><span class="o">.</span><span class="n">ThreeD</span><span class="p">:</span>
                <span class="n">pr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">px</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">py</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">pz</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">pr</span><span class="p">[</span><span class="n">pr</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="c1"># Don&#39;t divide in place.  That would change p&#39;s internals.</span>
                <span class="n">px</span> <span class="o">=</span> <span class="n">px</span><span class="o">/</span><span class="n">pr</span><span class="p">;</span> <span class="n">py</span> <span class="o">=</span> <span class="n">py</span><span class="o">/</span><span class="n">pr</span><span class="p">;</span> <span class="n">pz</span> <span class="o">=</span> <span class="n">pz</span><span class="o">/</span><span class="n">pr</span>
            <span class="n">dsq</span> <span class="o">=</span> <span class="p">(</span><span class="n">px</span><span class="o">-</span><span class="n">x1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">py</span><span class="o">-</span><span class="n">y1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">pz</span><span class="o">-</span><span class="n">z1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dsq</span><span class="p">)</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">d</span> <span class="o">&lt;</span> <span class="n">s1</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">_max_sep</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">low_mem</span> <span class="ow">and</span> <span class="n">p</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">cat1</span><span class="p">:</span>
                    <span class="n">p</span><span class="o">.</span><span class="n">unload</span><span class="p">()</span>
                <span class="k">continue</span>
            <span class="n">cat_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
            <span class="n">mask_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">low_mem</span> <span class="ow">and</span> <span class="n">p</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">cat1</span><span class="p">:</span>
                <span class="n">p</span><span class="o">.</span><span class="n">unload</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cat_list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cat2e</span> <span class="o">=</span> <span class="n">Catalog</span><span class="o">.</span><span class="n">combine</span><span class="p">(</span><span class="n">cat_list</span><span class="p">,</span> <span class="n">mask_list</span><span class="o">=</span><span class="n">mask_list</span><span class="p">,</span> <span class="n">low_mem</span><span class="o">=</span><span class="n">low_mem</span><span class="p">)</span>
            <span class="c1"># This is important for NN correlations to get the tot to work out right.</span>
            <span class="c1"># Basically, we treat the extended patch as though it included all of cat2</span>
            <span class="c1"># for the purposes of figuring out the right tot normalization.</span>
            <span class="n">cat2e</span><span class="o">.</span><span class="n">_sumw</span> <span class="o">=</span> <span class="n">sumw</span>
            <span class="k">if</span> <span class="n">cat1</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
                <span class="n">cat2e</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">cat1</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot; (expanded)&quot;</span>
        <span class="k">return</span> <span class="n">cat2e</span>

    <span class="k">def</span> <span class="nf">_single_process12</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">ij</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span> <span class="n">num_threads</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="n">force_write</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># Helper function for _process_all_auto and _process_cross for doing cross pairs.</span>
        <span class="n">temp</span><span class="o">.</span><span class="n">_clear</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">c2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trivially_zero</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">):</span>
            <span class="n">temp</span><span class="o">.</span><span class="n">process_cross</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span> <span class="n">num_threads</span><span class="o">=</span><span class="n">num_threads</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Skipping </span><span class="si">%s</span><span class="s1"> pair, which are too far apart &#39;</span> <span class="o">+</span>
                             <span class="s1">&#39;for this set of separations&#39;</span><span class="p">,</span><span class="n">ij</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">temp</span><span class="o">.</span><span class="n">nonzero</span> <span class="ow">or</span> <span class="n">force_write</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ij</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="n">ij</span><span class="p">]</span><span class="o">.</span><span class="n">nonzero</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="n">ij</span><span class="p">]</span> <span class="o">+=</span> <span class="n">temp</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="n">ij</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="bp">self</span> <span class="o">+=</span> <span class="n">temp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># NNCorrelation needs to add the tot value</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_add_tot</span><span class="p">(</span><span class="n">ij</span><span class="p">,</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_process_all_auto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cat1</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span> <span class="n">num_threads</span><span class="p">,</span> <span class="n">comm</span><span class="p">,</span> <span class="n">low_mem</span><span class="p">,</span> <span class="n">local</span><span class="p">):</span>

        <span class="k">def</span> <span class="nf">is_my_job</span><span class="p">(</span><span class="n">my_indices</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="c1"># Helper function to figure out if a given (i,j) job should be done on the</span>
            <span class="c1"># current process.</span>

            <span class="c1"># Always my job if not using MPI.</span>
            <span class="k">if</span> <span class="n">my_indices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>

            <span class="c1"># Now the tricky part.  If using MPI, we need to divide up the jobs smartly.</span>
            <span class="c1"># The first point is to divvy up the auto jobs evenly.  This is where most of the</span>
            <span class="c1"># work is done, so we want those to be spreads as evenly as possibly across procs.</span>
            <span class="c1"># Therefore, if both indices are mine, then do the job.</span>
            <span class="c1"># This reduces the number of catalogs this machine needs to load up.</span>
            <span class="c1"># If the auto i,i and j,j are both my job, then i and j are already being loaded</span>
            <span class="c1"># on this machine, so also do that job.</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">my_indices</span> <span class="ow">and</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">my_indices</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Rank </span><span class="si">%d</span><span class="s2">: Job (</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">) is mine.&quot;</span><span class="p">,</span><span class="n">rank</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">True</span>

            <span class="c1"># If neither index is mine, then it&#39;s not my job.</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">my_indices</span> <span class="ow">and</span> <span class="n">j</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">my_indices</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>

            <span class="c1"># For the other jobs, we want to minimize how many other catalogs need to be</span>
            <span class="c1"># loaded.  Unfortunately, the nature of pairs is such that we can&#39;t reduce this</span>
            <span class="c1"># too much.  For the set of jobs i,j where i belongs to proc 1 and j belongs to proc 2,</span>
            <span class="c1"># half of these pairs need to be assigned to each proc.</span>
            <span class="c1"># The best I could figure for this is to give even i to proc 1 and odd i to proc 2.</span>
            <span class="c1"># This means proc 1 has to load all the j catalogs, but proc 2 can skip half the i</span>
            <span class="c1"># catalogs.  This would naively have the result that procs with lower indices</span>
            <span class="c1"># have to load more catalogs than those with higher indices, since i &lt; j.</span>
            <span class="c1"># So we reverse the procedure when j-i &gt; n/2 to spread out the I/O more.</span>
            <span class="k">if</span> <span class="n">j</span><span class="o">-</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">//</span><span class="mi">2</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="p">(</span><span class="mi">0</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">my_indices</span> <span class="k">else</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">j</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="p">(</span><span class="mi">0</span> <span class="k">if</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">my_indices</span> <span class="k">else</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ret</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Rank </span><span class="si">%d</span><span class="s2">: Job (</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">) is mine.&quot;</span><span class="p">,</span><span class="n">rank</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">ret</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cat1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">cat1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">npatch</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">process_auto</span><span class="p">(</span><span class="n">cat1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span> <span class="n">num_threads</span><span class="o">=</span><span class="n">num_threads</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># When patch processing, keep track of the pair-wise results.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch1</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">npatch1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch2</span> <span class="o">=</span> <span class="n">cat1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">npatch</span> <span class="k">if</span> <span class="n">cat1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">npatch</span> <span class="o">!=</span> <span class="mi">1</span> <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="n">cat1</span><span class="p">)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch1</span>

            <span class="c1"># Setup for deciding when this is my job.</span>
            <span class="k">if</span> <span class="n">comm</span><span class="p">:</span>
                <span class="n">size</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">Get_size</span><span class="p">()</span>
                <span class="n">rank</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">Get_rank</span><span class="p">()</span>
                <span class="n">my_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">rank</span> <span class="o">//</span> <span class="n">size</span><span class="p">,</span> <span class="n">n</span> <span class="o">*</span> <span class="p">(</span><span class="n">rank</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="n">size</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Rank </span><span class="si">%d</span><span class="s2">: My indices are </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">rank</span><span class="p">,</span><span class="n">my_indices</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">my_indices</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_set_metric</span><span class="p">(</span><span class="n">metric</span><span class="p">,</span> <span class="n">cat1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">temp</span><span class="o">.</span><span class="n">results</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># Don&#39;t mess up the original results</span>

            <span class="k">if</span> <span class="n">local</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">ii</span><span class="p">,</span><span class="n">c1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cat1</span><span class="p">):</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="n">c1</span><span class="o">.</span><span class="n">_single_patch</span> <span class="k">if</span> <span class="n">c1</span><span class="o">.</span><span class="n">_single_patch</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">ii</span>
                    <span class="k">if</span> <span class="n">is_my_job</span><span class="p">(</span><span class="n">my_indices</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                        <span class="n">c1e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_expanded_patch</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">cat1</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span> <span class="n">low_mem</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Process patch </span><span class="si">%d</span><span class="s1"> with surrounding local patches&#39;</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_single_process12</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c1e</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">),</span> <span class="n">metric</span><span class="p">,</span> <span class="n">num_threads</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">low_mem</span><span class="p">:</span>
                            <span class="n">c1</span><span class="o">.</span><span class="n">unload</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">ii</span><span class="p">,</span><span class="n">c1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cat1</span><span class="p">):</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="n">c1</span><span class="o">.</span><span class="n">_single_patch</span> <span class="k">if</span> <span class="n">c1</span><span class="o">.</span><span class="n">_single_patch</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">ii</span>
                    <span class="k">if</span> <span class="n">is_my_job</span><span class="p">(</span><span class="n">my_indices</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                        <span class="n">temp</span><span class="o">.</span><span class="n">_clear</span><span class="p">()</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Process patch </span><span class="si">%d</span><span class="s1"> auto&#39;</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
                        <span class="n">temp</span><span class="o">.</span><span class="n">process_auto</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span> <span class="n">num_threads</span><span class="o">=</span><span class="n">num_threads</span><span class="p">)</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">)]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">)]</span> <span class="o">+=</span> <span class="n">temp</span>
                        <span class="bp">self</span> <span class="o">+=</span> <span class="n">temp</span>

                    <span class="k">for</span> <span class="n">jj</span><span class="p">,</span><span class="n">c2</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">cat1</span><span class="p">))[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">j</span> <span class="o">=</span> <span class="n">c2</span><span class="o">.</span><span class="n">_single_patch</span> <span class="k">if</span> <span class="n">c2</span><span class="o">.</span><span class="n">_single_patch</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">jj</span>
                        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span> <span class="ow">and</span> <span class="n">is_my_job</span><span class="p">(</span><span class="n">my_indices</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Process patches </span><span class="si">%d</span><span class="s1">, </span><span class="si">%d</span><span class="s1"> cross&#39;</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_single_process12</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">),</span> <span class="n">metric</span><span class="p">,</span> <span class="n">num_threads</span><span class="p">,</span> <span class="n">temp</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">low_mem</span> <span class="ow">and</span> <span class="n">jj</span> <span class="o">!=</span> <span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span>
                                <span class="c1"># Don&#39;t unload i+1, since that&#39;s the next one we&#39;ll need.</span>
                                <span class="n">c2</span><span class="o">.</span><span class="n">unload</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">low_mem</span><span class="p">:</span>
                        <span class="n">c1</span><span class="o">.</span><span class="n">unload</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">comm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">rank</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">Get_rank</span><span class="p">()</span>
                <span class="n">size</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">Get_size</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Rank </span><span class="si">%d</span><span class="s2">: Completed jobs </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">rank</span><span class="p">,</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
                <span class="c1"># Send all the results back to rank 0 process.</span>
                <span class="k">if</span> <span class="n">rank</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">comm</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">size</span><span class="p">):</span>
                        <span class="n">temp</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
                        <span class="bp">self</span> <span class="o">+=</span> <span class="n">temp</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">temp</span><span class="o">.</span><span class="n">results</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_process_all_cross</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cat1</span><span class="p">,</span> <span class="n">cat2</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span> <span class="n">num_threads</span><span class="p">,</span> <span class="n">comm</span><span class="p">,</span> <span class="n">low_mem</span><span class="p">,</span> <span class="n">local</span><span class="p">):</span>

        <span class="k">def</span> <span class="nf">is_my_job</span><span class="p">(</span><span class="n">my_indices</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">):</span>
            <span class="c1"># Helper function to figure out if a given (i,j) job should be done on the</span>
            <span class="c1"># current process.</span>

            <span class="c1"># Always my job if not using MPI.</span>
            <span class="k">if</span> <span class="n">my_indices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>

            <span class="c1"># This is much simpler than in the auto case, since the set of catalogs for</span>
            <span class="c1"># cat1 and cat2 are different, we can just split up one of them among the jobs.</span>
            <span class="k">if</span> <span class="n">n1</span> <span class="o">&gt;</span> <span class="n">n2</span><span class="p">:</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">j</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">my_indices</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Rank </span><span class="si">%d</span><span class="s2">: Job (</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">) is mine.&quot;</span><span class="p">,</span><span class="n">rank</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cat1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">cat2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">cat1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">npatch</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">cat2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">npatch</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">process_cross</span><span class="p">(</span><span class="n">cat1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cat2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span> <span class="n">num_threads</span><span class="o">=</span><span class="n">num_threads</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># When patch processing, keep track of the pair-wise results.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch1</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">npatch1</span> <span class="o">=</span> <span class="n">cat1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">npatch</span> <span class="k">if</span> <span class="n">cat1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">npatch</span> <span class="o">!=</span> <span class="mi">1</span> <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="n">cat1</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">npatch2</span> <span class="o">=</span> <span class="n">cat2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">npatch</span> <span class="k">if</span> <span class="n">cat2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">npatch</span> <span class="o">!=</span> <span class="mi">1</span> <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="n">cat2</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch1</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch2</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch1</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch2</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Cross correlation requires both catalogs use the same patches.&quot;</span><span class="p">)</span>

            <span class="c1"># Setup for deciding when this is my job.</span>
            <span class="n">n1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch1</span>
            <span class="n">n2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch2</span>
            <span class="k">if</span> <span class="n">comm</span><span class="p">:</span>
                <span class="n">size</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">Get_size</span><span class="p">()</span>
                <span class="n">rank</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">Get_rank</span><span class="p">()</span>
                <span class="n">n</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span><span class="n">n2</span><span class="p">)</span>
                <span class="n">my_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">rank</span> <span class="o">//</span> <span class="n">size</span><span class="p">,</span> <span class="n">n</span> <span class="o">*</span> <span class="p">(</span><span class="n">rank</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="n">size</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Rank </span><span class="si">%d</span><span class="s2">: My indices are </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">rank</span><span class="p">,</span><span class="n">my_indices</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">my_indices</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_set_metric</span><span class="p">(</span><span class="n">metric</span><span class="p">,</span> <span class="n">cat1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">coords</span><span class="p">,</span> <span class="n">cat2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">temp</span><span class="o">.</span><span class="n">results</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># Don&#39;t mess up the original results</span>

            <span class="k">if</span> <span class="n">local</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">ii</span><span class="p">,</span><span class="n">c1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cat1</span><span class="p">):</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="n">c1</span><span class="o">.</span><span class="n">_single_patch</span> <span class="k">if</span> <span class="n">c1</span><span class="o">.</span><span class="n">_single_patch</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">ii</span>
                    <span class="k">if</span> <span class="n">is_my_job</span><span class="p">(</span><span class="n">my_indices</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">):</span>
                        <span class="n">c2e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_expanded_patch</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">cat2</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span> <span class="n">low_mem</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Process patch </span><span class="si">%d</span><span class="s1"> with surrounding local patches&#39;</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_single_process12</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2e</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">),</span> <span class="n">metric</span><span class="p">,</span> <span class="n">num_threads</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">low_mem</span><span class="p">:</span>
                            <span class="n">c1</span><span class="o">.</span><span class="n">unload</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">ii</span><span class="p">,</span><span class="n">c1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cat1</span><span class="p">):</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="n">c1</span><span class="o">.</span><span class="n">_single_patch</span> <span class="k">if</span> <span class="n">c1</span><span class="o">.</span><span class="n">_single_patch</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">ii</span>
                    <span class="k">for</span> <span class="n">jj</span><span class="p">,</span><span class="n">c2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cat2</span><span class="p">):</span>
                        <span class="n">j</span> <span class="o">=</span> <span class="n">c2</span><span class="o">.</span><span class="n">_single_patch</span> <span class="k">if</span> <span class="n">c2</span><span class="o">.</span><span class="n">_single_patch</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">jj</span>
                        <span class="k">if</span> <span class="n">is_my_job</span><span class="p">(</span><span class="n">my_indices</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">):</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Process patches </span><span class="si">%d</span><span class="s1">, </span><span class="si">%d</span><span class="s1"> cross&#39;</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_single_process12</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">),</span> <span class="n">metric</span><span class="p">,</span> <span class="n">num_threads</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span>
                                                   <span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="n">j</span> <span class="ow">or</span> <span class="n">n1</span><span class="o">==</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">n2</span><span class="o">==</span><span class="mi">1</span><span class="p">))</span>
                            <span class="k">if</span> <span class="n">low_mem</span><span class="p">:</span>
                                <span class="n">c2</span><span class="o">.</span><span class="n">unload</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">low_mem</span><span class="p">:</span>
                        <span class="n">c1</span><span class="o">.</span><span class="n">unload</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">comm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">rank</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">Get_rank</span><span class="p">()</span>
                <span class="n">size</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">Get_size</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Rank </span><span class="si">%d</span><span class="s2">: Completed jobs </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">rank</span><span class="p">,</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
                <span class="c1"># Send all the results back to rank 0 process.</span>
                <span class="k">if</span> <span class="n">rank</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">comm</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">size</span><span class="p">):</span>
                        <span class="n">temp</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
                        <span class="bp">self</span> <span class="o">+=</span> <span class="n">temp</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">temp</span><span class="o">.</span><span class="n">results</span><span class="p">)</span>

<div class="viewcode-block" id="Corr2.getStat"><a class="viewcode-back" href="../../correlation2.html#treecorr.Corr2.getStat">[docs]</a>    <span class="k">def</span> <span class="nf">getStat</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The standard statistic for the current correlation object as a 1-d array.</span>

<span class="sd">        Usually, this is just self.xi.  But if the metric is TwoD, this becomes self.xi.ravel().</span>
<span class="sd">        And for `GGCorrelation` (and other complex auto-correlations), it is the concatenation of</span>
<span class="sd">        self.xip and self.xim.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span></div>

<div class="viewcode-block" id="Corr2.getWeight"><a class="viewcode-back" href="../../correlation2.html#treecorr.Corr2.getWeight">[docs]</a>    <span class="k">def</span> <span class="nf">getWeight</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The weight array for the current correlation object as a 1-d array.</span>

<span class="sd">        This is the weight array corresponding to `getStat`. Usually just self.weight, but</span>
<span class="sd">        raveled for TwoD and duplicated for `GGCorrelation`, etc. to match what</span>
<span class="sd">        `getStat` does in those cases.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">_process_auto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cat</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_threads</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># This is only valid for some classes, but it common enough that we do the implementation</span>
        <span class="c1"># here and only when appropriate define the non underscore version.</span>
        <span class="k">if</span> <span class="n">cat</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Starting process </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_letters</span><span class="si">}</span><span class="s1"> auto-correlations&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Starting process </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_letters</span><span class="si">}</span><span class="s1"> auto-correlations for cat %s.&#39;</span><span class="p">,</span>
                             <span class="n">cat</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_set_metric</span><span class="p">(</span><span class="n">metric</span><span class="p">,</span> <span class="n">cat</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_num_threads</span><span class="p">(</span><span class="n">num_threads</span><span class="p">)</span>
        <span class="n">min_size</span><span class="p">,</span> <span class="n">max_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_minmax_size</span><span class="p">()</span>

        <span class="n">getField</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">cat</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;get</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_letter1</span><span class="si">}</span><span class="s2">Field&quot;</span><span class="p">)</span>
        <span class="n">field</span> <span class="o">=</span> <span class="n">getField</span><span class="p">(</span><span class="n">min_size</span><span class="o">=</span><span class="n">min_size</span><span class="p">,</span> <span class="n">max_size</span><span class="o">=</span><span class="n">max_size</span><span class="p">,</span>
                         <span class="n">split_method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">split_method</span><span class="p">,</span> <span class="n">brute</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">brute</span><span class="p">),</span>
                         <span class="n">min_top</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">min_top</span><span class="p">,</span> <span class="n">max_top</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_top</span><span class="p">,</span>
                         <span class="n">coords</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Starting </span><span class="si">%d</span><span class="s1"> jobs.&#39;</span><span class="p">,</span><span class="n">field</span><span class="o">.</span><span class="n">nTopLevelNodes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">corr</span><span class="o">.</span><span class="n">processAuto</span><span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_dots</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metric</span><span class="p">)</span>

<div class="viewcode-block" id="Corr2.process_cross"><a class="viewcode-back" href="../../correlation2.html#treecorr.Corr2.process_cross">[docs]</a>    <span class="k">def</span> <span class="nf">process_cross</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cat1</span><span class="p">,</span> <span class="n">cat2</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_threads</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Process a single pair of catalogs, accumulating the cross-correlation.</span>

<span class="sd">        This accumulates the weighted sums into the bins, but does not finalize</span>
<span class="sd">        the calculation by dividing by the total weight at the end.  After</span>
<span class="sd">        calling this function as often as desired, the ``finalize`` command will</span>
<span class="sd">        finish the calculation.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            cat1 (Catalog):     The first catalog to process</span>
<span class="sd">            cat2 (Catalog):     The second catalog to process</span>
<span class="sd">            metric (str):       Which metric to use.  See `Metrics` for details.</span>
<span class="sd">                                (default: &#39;Euclidean&#39;; this value can also be given in the</span>
<span class="sd">                                constructor in the config dict.)</span>
<span class="sd">            num_threads (int):  How many OpenMP threads to use during the calculation.</span>
<span class="sd">                                (default: use the number of cpu cores; this value can also be given</span>
<span class="sd">                                in the constructor in the config dict.)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">cat1</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span> <span class="ow">and</span> <span class="n">cat2</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Starting process </span><span class="si">%s%s</span><span class="s1"> cross-correlations&#39;</span><span class="p">,</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">_letter1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_letter2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Starting process </span><span class="si">%s%s</span><span class="s1"> cross-correlations for cats </span><span class="si">%s</span><span class="s1">, </span><span class="si">%s</span><span class="s1">.&#39;</span><span class="p">,</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">_letter1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_letter2</span><span class="p">,</span> <span class="n">cat1</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">cat2</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_set_metric</span><span class="p">(</span><span class="n">metric</span><span class="p">,</span> <span class="n">cat1</span><span class="o">.</span><span class="n">coords</span><span class="p">,</span> <span class="n">cat2</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_num_threads</span><span class="p">(</span><span class="n">num_threads</span><span class="p">)</span>
        <span class="n">min_size</span><span class="p">,</span> <span class="n">max_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_minmax_size</span><span class="p">()</span>

        <span class="n">getField1</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">cat1</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;get</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_letter1</span><span class="si">}</span><span class="s2">Field&quot;</span><span class="p">)</span>
        <span class="n">f1</span> <span class="o">=</span> <span class="n">getField1</span><span class="p">(</span><span class="n">min_size</span><span class="o">=</span><span class="n">min_size</span><span class="p">,</span> <span class="n">max_size</span><span class="o">=</span><span class="n">max_size</span><span class="p">,</span>
                       <span class="n">split_method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">split_method</span><span class="p">,</span>
                       <span class="n">brute</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">brute</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">brute</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span>
                       <span class="n">min_top</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">min_top</span><span class="p">,</span> <span class="n">max_top</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_top</span><span class="p">,</span>
                       <span class="n">coords</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
        <span class="n">getField2</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">cat2</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;get</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_letter2</span><span class="si">}</span><span class="s2">Field&quot;</span><span class="p">)</span>
        <span class="n">f2</span> <span class="o">=</span> <span class="n">getField2</span><span class="p">(</span><span class="n">min_size</span><span class="o">=</span><span class="n">min_size</span><span class="p">,</span> <span class="n">max_size</span><span class="o">=</span><span class="n">max_size</span><span class="p">,</span>
                       <span class="n">split_method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">split_method</span><span class="p">,</span>
                       <span class="n">brute</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">brute</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">brute</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span>
                       <span class="n">min_top</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">min_top</span><span class="p">,</span> <span class="n">max_top</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_top</span><span class="p">,</span>
                       <span class="n">coords</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Starting </span><span class="si">%d</span><span class="s1"> jobs.&#39;</span><span class="p">,</span><span class="n">f1</span><span class="o">.</span><span class="n">nTopLevelNodes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">corr</span><span class="o">.</span><span class="n">processCross</span><span class="p">(</span><span class="n">f1</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">f2</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_dots</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metric</span><span class="p">)</span></div>

<div class="viewcode-block" id="Corr2.process"><a class="viewcode-back" href="../../correlation2.html#treecorr.Corr2.process">[docs]</a>    <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cat1</span><span class="p">,</span> <span class="n">cat2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_threads</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">low_mem</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">initialize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">finalize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">patch_method</span><span class="o">=</span><span class="s1">&#39;global&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the correlation function.</span>

<span class="sd">        - If only 1 argument is given, then compute an auto-correlation function.</span>
<span class="sd">        - If 2 arguments are given, then compute a cross-correlation function.</span>

<span class="sd">        Both arguments may be lists, in which case all items in the list are used</span>
<span class="sd">        for that element of the correlation.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            cat1 (Catalog):     A catalog or list of catalogs for the first field.</span>
<span class="sd">            cat2 (Catalog):     A catalog or list of catalogs for the second field, if any.</span>
<span class="sd">                                (default: None)</span>
<span class="sd">            metric (str):       Which metric to use.  See `Metrics` for details.</span>
<span class="sd">                                (default: &#39;Euclidean&#39;; this value can also be given in the</span>
<span class="sd">                                constructor in the config dict.)</span>
<span class="sd">            num_threads (int):  How many OpenMP threads to use during the calculation.</span>
<span class="sd">                                (default: use the number of cpu cores; this value can also be given</span>
<span class="sd">                                in the constructor in the config dict.)</span>
<span class="sd">            comm (mpi4py.Comm): If running MPI, an mpi4py Comm object to communicate between</span>
<span class="sd">                                processes.  If used, the rank=0 process will have the final</span>
<span class="sd">                                computation. This only works if using patches. (default: None)</span>
<span class="sd">            low_mem (bool):     Whether to sacrifice a little speed to try to reduce memory usage.</span>
<span class="sd">                                This only works if using patches. (default: False)</span>
<span class="sd">            initialize (bool):  Whether to begin the calculation with a call to</span>
<span class="sd">                                `Corr2.clear`.  (default: True)</span>
<span class="sd">            finalize (bool):    Whether to complete the calculation with a call to finalize.</span>
<span class="sd">                                (default: True)</span>
<span class="sd">            patch_method (str): Which patch method to use. (default: &#39;global&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">math</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_letter1</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_letter2</span> <span class="ow">and</span> <span class="n">cat2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cat2 is required for </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_cls</span><span class="si">}</span><span class="s2">.process&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">initialize</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_processed_cats1</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_processed_cats2</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">patch_method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;local&#39;</span><span class="p">,</span> <span class="s1">&#39;global&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid patch_method </span><span class="si">%s</span><span class="s2">&quot;</span><span class="o">%</span><span class="n">patch_method</span><span class="p">)</span>
        <span class="n">local</span> <span class="o">=</span> <span class="n">patch_method</span> <span class="o">==</span> <span class="s1">&#39;local&#39;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cat1</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span>
            <span class="n">cat1</span> <span class="o">=</span> <span class="n">cat1</span><span class="o">.</span><span class="n">get_patches</span><span class="p">(</span><span class="n">low_mem</span><span class="o">=</span><span class="n">low_mem</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cat2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cat2</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span>
            <span class="n">cat2</span> <span class="o">=</span> <span class="n">cat2</span><span class="o">.</span><span class="n">get_patches</span><span class="p">(</span><span class="n">low_mem</span><span class="o">=</span><span class="n">low_mem</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">cat2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_process_all_auto</span><span class="p">(</span><span class="n">cat1</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span> <span class="n">num_threads</span><span class="p">,</span> <span class="n">comm</span><span class="p">,</span> <span class="n">low_mem</span><span class="p">,</span> <span class="n">local</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_process_all_cross</span><span class="p">(</span><span class="n">cat1</span><span class="p">,</span> <span class="n">cat2</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span> <span class="n">num_threads</span><span class="p">,</span> <span class="n">comm</span><span class="p">,</span> <span class="n">low_mem</span><span class="p">,</span> <span class="n">local</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_processed_cats1</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">cat1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cat2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_processed_cats2</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">cat2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">finalize</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cat2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">var1</span> <span class="o">=</span> <span class="n">var2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculateVar1</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_processed_cats1</span><span class="p">,</span> <span class="n">low_mem</span><span class="o">=</span><span class="n">low_mem</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">var1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;var%s = %f: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_sig1</span><span class="si">}</span><span class="s2"> = %f&quot;</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">_letter1</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span> <span class="n">var1</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">var1</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">var1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculateVar1</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_processed_cats1</span><span class="p">,</span> <span class="n">low_mem</span><span class="o">=</span><span class="n">low_mem</span><span class="p">)</span>
                <span class="n">var2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculateVar2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_processed_cats2</span><span class="p">,</span> <span class="n">low_mem</span><span class="o">=</span><span class="n">low_mem</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_letter1</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_letter2</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">var1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;var%s1 = %f: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_sig1</span><span class="si">}</span><span class="s2"> = %f&quot;</span><span class="p">,</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">_letter1</span><span class="p">,</span> <span class="n">var1</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">var1</span><span class="p">))</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;var%s2 = %f: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_sig2</span><span class="si">}</span><span class="s2"> = %f&quot;</span><span class="p">,</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">_letter2</span><span class="p">,</span> <span class="n">var2</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">var2</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">var1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;var%s = %f: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_sig1</span><span class="si">}</span><span class="s2"> = %f&quot;</span><span class="p">,</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">_letter1</span><span class="p">,</span> <span class="n">var1</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">var1</span><span class="p">))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;var%s = %f: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_sig2</span><span class="si">}</span><span class="s2"> = %f&quot;</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">_letter2</span><span class="p">,</span> <span class="n">var2</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">var2</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">var1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">var2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">finalize</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">finalize</span><span class="p">(</span><span class="n">var2</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">finalize</span><span class="p">(</span><span class="n">var1</span><span class="p">,</span> <span class="n">var2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_processed_cats1</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_processed_cats2</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">_finalize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">mask1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span> <span class="o">!=</span> <span class="mi">0</span>
        <span class="n">mask2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span> <span class="o">==</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xi1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_xi1</span><span class="p">[</span><span class="n">mask1</span><span class="p">]</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">[</span><span class="n">mask1</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xi2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_xi2</span><span class="p">[</span><span class="n">mask1</span><span class="p">]</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">[</span><span class="n">mask1</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xi3</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_xi3</span><span class="p">[</span><span class="n">mask1</span><span class="p">]</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">[</span><span class="n">mask1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_xi4</span><span class="p">[</span><span class="n">mask1</span><span class="p">]</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">[</span><span class="n">mask1</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">meanr</span><span class="p">[</span><span class="n">mask1</span><span class="p">]</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">[</span><span class="n">mask1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meanlogr</span><span class="p">[</span><span class="n">mask1</span><span class="p">]</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">[</span><span class="n">mask1</span><span class="p">]</span>

        <span class="c1"># Update the units of meanlogr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_apply_units</span><span class="p">(</span><span class="n">mask1</span><span class="p">)</span>

        <span class="c1"># Use meanlogr when available, but set to nominal when no pairs in bin.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meanr</span><span class="p">[</span><span class="n">mask2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rnom</span><span class="p">[</span><span class="n">mask2</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meanlogr</span><span class="p">[</span><span class="n">mask2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">logr</span><span class="p">[</span><span class="n">mask2</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Clear the data vectors</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_xi1</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_xi2</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_xi3</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_xi4</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meanr</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meanlogr</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">npairs</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cov</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add a second Correlation object&#39;s data to this one.</span>

<span class="sd">        .. note::</span>

<span class="sd">            For this to make sense, both objects should not have had ``finalize`` called yet.</span>
<span class="sd">            Then, after adding them together, you should call ``finalize`` on the sum.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Can only add another </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_cls</span><span class="si">}</span><span class="s2"> object&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nbins</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_nbins</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">min_sep</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">min_sep</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">max_sep</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">max_sep</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_cls</span><span class="si">}</span><span class="s2"> to be added is not compatible with this one.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_set_metric</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">metric</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">coords</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">nonzero</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_xi1</span><span class="p">[:]</span> <span class="o">+=</span> <span class="n">other</span><span class="o">.</span><span class="n">_xi1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_xi2</span><span class="p">[:]</span> <span class="o">+=</span> <span class="n">other</span><span class="o">.</span><span class="n">_xi2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_xi3</span><span class="p">[:]</span> <span class="o">+=</span> <span class="n">other</span><span class="o">.</span><span class="n">_xi3</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_xi4</span><span class="p">[:]</span> <span class="o">+=</span> <span class="n">other</span><span class="o">.</span><span class="n">_xi4</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meanr</span><span class="p">[:]</span> <span class="o">+=</span> <span class="n">other</span><span class="o">.</span><span class="n">meanr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meanlogr</span><span class="p">[:]</span> <span class="o">+=</span> <span class="n">other</span><span class="o">.</span><span class="n">meanlogr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span> <span class="o">+=</span> <span class="n">other</span><span class="o">.</span><span class="n">weight</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">npairs</span><span class="p">[:]</span> <span class="o">+=</span> <span class="n">other</span><span class="o">.</span><span class="n">npairs</span>
        <span class="k">return</span> <span class="bp">self</span>

<div class="viewcode-block" id="Corr2.estimate_cov"><a class="viewcode-back" href="../../correlation2.html#treecorr.Corr2.estimate_cov">[docs]</a>    <span class="k">def</span> <span class="nf">estimate_cov</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Estimate the covariance matrix based on the data</span>

<span class="sd">        This function will calculate an estimate of the covariance matrix according to the</span>
<span class="sd">        given method.</span>

<span class="sd">        Options for ``method`` include:</span>

<span class="sd">            - &#39;shot&#39; = The variance based on &quot;shot noise&quot; only.  This includes the Poisson</span>
<span class="sd">              counts of points for N statistics, shape noise for G statistics, and the observed</span>
<span class="sd">              scatter in the values for K statistics.  In this case, the returned value will</span>
<span class="sd">              only be the diagonal.  Use np.diagonal(cov) if you actually want a full</span>
<span class="sd">              matrix from this.</span>
<span class="sd">            - &#39;jackknife&#39; = A jackknife estimate of the covariance matrix based on the scatter</span>
<span class="sd">              in the measurement when excluding one patch at a time.</span>
<span class="sd">            - &#39;sample&#39; = An estimate based on the sample covariance of a set of samples,</span>
<span class="sd">              taken as the patches of the input catalog.</span>
<span class="sd">            - &#39;bootstrap&#39; = A bootstrap covariance estimate. It selects patches at random with</span>
<span class="sd">              replacement and then generates the statistic using all the auto-correlations at</span>
<span class="sd">              their selected repetition plus all the cross terms that aren&#39;t actually auto terms.</span>
<span class="sd">            - &#39;marked_bootstrap&#39; = An estimate based on a marked-point bootstrap resampling of the</span>
<span class="sd">              patches.  Similar to bootstrap, but only samples the patches of the first catalog and</span>
<span class="sd">              uses all patches from the second catalog that correspond to each patch selection of</span>
<span class="sd">              the first catalog.  Based on the algorithm presented in Loh (2008).</span>
<span class="sd">              cf. https://ui.adsabs.harvard.edu/abs/2008ApJ...681..726L/</span>

<span class="sd">        Both &#39;bootstrap&#39; and &#39;marked_bootstrap&#39; use the num_bootstrap parameter, which can be set on</span>
<span class="sd">        construction.</span>

<span class="sd">        .. note::</span>

<span class="sd">            For most classes, there is only a single statistic, so this calculates a covariance</span>
<span class="sd">            matrix for that vector.  `GGCorrelation` other complex auto-correaltions have two:</span>
<span class="sd">            ``xip`` and ``xim``, so in this case the full data vector is ``xip`` followed by</span>
<span class="sd">            ``xim``, and this calculates the covariance matrix for that full vector including</span>
<span class="sd">            both statistics.  The helper function `getStat` returns the relevant statistic in all</span>
<span class="sd">            cases.</span>

<span class="sd">        In all cases, the relevant processing needs to already have been completed and finalized.</span>
<span class="sd">        And for all methods other than &#39;shot&#39;, the processing should have involved an appropriate</span>
<span class="sd">        number of patches -- preferably more patches than the length of the vector for your</span>
<span class="sd">        statistic, although this is not checked.</span>

<span class="sd">        The default data vector to use for the covariance matrix is given by the method</span>
<span class="sd">        `getStat`.  As noted above, this is usually just self.xi.  However, there is an option</span>
<span class="sd">        to compute the covariance of some other function of the correlation object by providing</span>
<span class="sd">        an arbitrary function, ``func``, which should act on the current correlation object</span>
<span class="sd">        and return the data vector of interest.</span>

<span class="sd">        For instance, for an `NGCorrelation`, you might want to compute the covariance of the</span>
<span class="sd">        imaginary part, ``ng.xi_im``, rather than the real part.  In this case you could use</span>

<span class="sd">            &gt;&gt;&gt; func = lambda ng: ng.xi_im</span>

<span class="sd">        The return value from this func should be a single numpy array. (This is not directly</span>
<span class="sd">        checked, but you&#39;ll probably get some kind of exception if it doesn&#39;t behave as expected.)</span>

<span class="sd">        .. note::</span>

<span class="sd">            The optional ``func`` parameter is not valid in conjunction with ``method=&#39;shot&#39;``.</span>
<span class="sd">            It only works for the methods that are based on patch combinations.</span>

<span class="sd">        This function can be parallelized by passing the comm argument as an mpi4py communicator</span>
<span class="sd">        to parallelize using that.  For MPI, all processes should have the same inputs.</span>
<span class="sd">        If method == &quot;shot&quot; then parallelization has no effect.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            method (str):       Which method to use to estimate the covariance matrix.</span>
<span class="sd">            func (function):    A unary function that acts on the current correlation object and</span>
<span class="sd">                                returns the desired data vector. [default: None, which is</span>
<span class="sd">                                equivalent to ``lambda corr: corr.getStat()``.</span>
<span class="sd">            comm (mpi comm)     If not None, run under MPI</span>

<span class="sd">        Returns:</span>
<span class="sd">            A numpy array with the estimated covariance matrix.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Need to convert it to a function of the first item in the list.</span>
            <span class="n">all_func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">corrs</span><span class="p">:</span> <span class="n">func</span><span class="p">(</span><span class="n">corrs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">all_func</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">estimate_multi_cov</span><span class="p">([</span><span class="bp">self</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="n">all_func</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="n">comm</span><span class="p">)</span></div>

<div class="viewcode-block" id="Corr2.build_cov_design_matrix"><a class="viewcode-back" href="../../correlation2.html#treecorr.Corr2.build_cov_design_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">build_cov_design_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Build the design matrix that is used for estimating the covariance matrix.</span>

<span class="sd">        The design matrix for patch-based covariance estimates is a matrix where each row</span>
<span class="sd">        corresponds to a different estimate of the data vector, :math:`\\xi_i` (or</span>
<span class="sd">        :math:`f(\\xi_i)` if using the optional ``func`` parameter).</span>

<span class="sd">        The different of rows in the matrix for each valid ``method`` are:</span>

<span class="sd">            - &#39;shot&#39;: This method is not valid here.</span>
<span class="sd">            - &#39;jackknife&#39;: The data vector when excluding a single patch.</span>
<span class="sd">            - &#39;sample&#39;: The data vector using only a single patch for the first catalog.</span>
<span class="sd">            - &#39;bootstrap&#39;: The data vector for a random resampling of the patches keeping the</span>
<span class="sd">              sample total number, but allowing some to repeat.  Cross terms from repeated patches</span>
<span class="sd">              are excluded (since they are really auto terms).</span>
<span class="sd">            - &#39;marked_bootstrap&#39;: The data vector for a random resampling of patches in the first</span>
<span class="sd">              catalog, using all patches for the second catalog.  Based on the algorithm in</span>
<span class="sd">              Loh(2008).</span>

<span class="sd">        See `estimate_cov` for more details.</span>

<span class="sd">        The return value includes both the design matrix and a vector of weights (the total weight</span>
<span class="sd">        array in the computed correlation functions).  The weights are used for the sample method</span>
<span class="sd">        when estimating the covariance matrix.  The other methods ignore them, but they are provided</span>
<span class="sd">        here in case they are useful.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            method (str):       Which method to use to estimate the covariance matrix.</span>
<span class="sd">            func (function):    A unary function that takes the list ``corrs`` and returns the</span>
<span class="sd">                                desired full data vector. [default: None, which is equivalent to</span>
<span class="sd">                                ``lambda corrs: np.concatenate([c.getStat() for c in corrs])``]</span>
<span class="sd">            comm (mpi comm)     If not None, run under MPI</span>

<span class="sd">        Returns:</span>
<span class="sd">            (A, w), numpy arrays with the design matrix and weights respectively.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Need to convert it to a function of the first item in the list.</span>
            <span class="n">all_func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">corrs</span><span class="p">:</span> <span class="n">func</span><span class="p">(</span><span class="n">corrs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">all_func</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">build_multi_cov_design_matrix</span><span class="p">([</span><span class="bp">self</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="n">all_func</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="n">comm</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_set_num_threads</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_threads</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">num_threads</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">num_threads</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;num_threads&#39;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
        <span class="c1"># Recheck.</span>
        <span class="k">if</span> <span class="n">num_threads</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Set num_threads automatically&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Set num_threads = </span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">,</span><span class="n">num_threads</span><span class="p">)</span>
        <span class="n">set_omp_threads</span><span class="p">(</span><span class="n">num_threads</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_metric</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span> <span class="n">coords1</span><span class="p">,</span> <span class="n">coords2</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">metric</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">metric</span> <span class="o">=</span> <span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">,</span><span class="s1">&#39;metric&#39;</span><span class="p">,</span><span class="nb">str</span><span class="p">,</span><span class="s1">&#39;Euclidean&#39;</span><span class="p">)</span>
        <span class="n">coords</span><span class="p">,</span> <span class="n">metric</span> <span class="o">=</span> <span class="n">parse_metric</span><span class="p">(</span><span class="n">metric</span><span class="p">,</span> <span class="n">coords1</span><span class="p">,</span> <span class="n">coords2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">coords</span> <span class="o">!=</span> <span class="s1">&#39;3d&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_rpar</span> <span class="o">!=</span> <span class="o">-</span><span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="o">.</span><span class="n">max</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;min_rpar is only valid for 3d coordinates&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_rpar</span> <span class="o">!=</span> <span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="o">.</span><span class="n">max</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;max_rpar is only valid for 3d coordinates&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_type</span> <span class="o">==</span> <span class="s1">&#39;TwoD&#39;</span> <span class="ow">and</span> <span class="p">(</span><span class="n">coords</span> <span class="o">!=</span> <span class="s1">&#39;flat&#39;</span> <span class="ow">or</span> <span class="n">metric</span> <span class="o">!=</span> <span class="s1">&#39;Euclidean&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;TwoD binning is only valid with flat coordinates &quot;</span>
                             <span class="s2">&quot;with a Euclidean metric.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sep_units</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span> <span class="ow">and</span> <span class="n">coords</span> <span class="o">==</span> <span class="s1">&#39;3d&#39;</span> <span class="ow">and</span> <span class="n">metric</span> <span class="o">!=</span> <span class="s1">&#39;Arc&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;sep_units is invalid with 3d coordinates. &quot;</span>
                             <span class="s2">&quot;min_sep and max_sep should be in the same units as r (or x,y,z).&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;Periodic&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">xperiod</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">yperiod</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="p">(</span><span class="n">coords</span><span class="o">==</span><span class="s1">&#39;3d&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">zperiod</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Periodic metric requires setting the period to use.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">xperiod</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">yperiod</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">zperiod</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;period options are not valid for </span><span class="si">%s</span><span class="s2"> metric.&quot;</span><span class="o">%</span><span class="n">metric</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">metric</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">coords</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Detected a change in catalog coordinate systems.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">+</span>
                                    <span class="s2">&quot;This probably doesn&#39;t make sense!&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">metric</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metric</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Detected a change in metric.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">+</span>
                                    <span class="s2">&quot;This probably doesn&#39;t make sense!&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">coords</span> <span class="o">=</span> <span class="n">coords</span>  <span class="c1"># These are the regular string values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metric</span> <span class="o">=</span> <span class="n">metric</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_coords</span> <span class="o">=</span> <span class="n">coord_enum</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>  <span class="c1"># These are the C++-layer enums</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_metric</span> <span class="o">=</span> <span class="n">metric_enum</span><span class="p">(</span><span class="n">metric</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_apply_units</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span> <span class="o">==</span> <span class="s1">&#39;spherical&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;Euclidean&#39;</span><span class="p">:</span>
            <span class="c1"># Then our distances are all angles.  Convert from the chord distance to a real angle.</span>
            <span class="c1"># L = 2 sin(theta/2)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">meanr</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meanr</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">meanlogr</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span> <span class="mf">2.</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meanlogr</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meanr</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sep_units</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meanlogr</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_log_sep_units</span>

    <span class="k">def</span> <span class="nf">_get_minmax_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;Euclidean&#39;</span><span class="p">:</span>
            <span class="c1"># The minimum size cell that will be useful is one where two cells that just barely</span>
            <span class="c1"># don&#39;t split have (d + s1 + s2) = minsep</span>
            <span class="c1"># The largest s2 we need to worry about is s2 = 2s1.</span>
            <span class="c1"># i.e. d = minsep - 3s1  and s1 = 0.5 * bd</span>
            <span class="c1">#      d = minsep - 1.5 bd</span>
            <span class="c1">#      d = minsep / (1+1.5 b)</span>
            <span class="c1">#      s = 0.5 * b * minsep / (1+1.5 b)</span>
            <span class="c1">#        = b * minsep / (2+3b)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_type</span> <span class="o">==</span> <span class="s1">&#39;Log&#39;</span><span class="p">:</span>
                <span class="n">b1</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">angle_slop</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">)</span>
                <span class="n">min_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_min_sep</span> <span class="o">*</span> <span class="n">b1</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.</span><span class="o">+</span><span class="mf">3.</span><span class="o">*</span><span class="n">b1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle_slop</span>
                <span class="n">min_size</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_min_sep</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.</span><span class="o">+</span><span class="mf">3.</span><span class="o">*</span><span class="n">a</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span>

            <span class="c1"># The maximum size cell that will be useful is one where a cell of size s will</span>
            <span class="c1"># be split at the maximum separation even if the other size = 0.</span>
            <span class="c1"># i.e. max_size = max_sep * b</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_type</span> <span class="o">==</span> <span class="s1">&#39;Log&#39;</span><span class="p">:</span>
                <span class="n">max_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_sep</span> <span class="o">*</span> <span class="n">b1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">max_size</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_sep</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">min_size</span><span class="p">,</span> <span class="n">max_size</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># For other metrics, the above calculation doesn&#39;t really apply, so just skip</span>
            <span class="c1"># this relatively modest optimization and go all the way to the leaves.</span>
            <span class="c1"># (And for the max_size, always split 10 levels for the top-level cells.)</span>
            <span class="k">return</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span>

<div class="viewcode-block" id="Corr2.sample_pairs"><a class="viewcode-back" href="../../correlation2.html#treecorr.Corr2.sample_pairs">[docs]</a>    <span class="k">def</span> <span class="nf">sample_pairs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">cat1</span><span class="p">,</span> <span class="n">cat2</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">min_sep</span><span class="p">,</span> <span class="n">max_sep</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a random sample of n pairs whose separations fall between min_sep and max_sep.</span>

<span class="sd">        This would typically be used to get some random subset of the indices of pairs that</span>
<span class="sd">        fell into a particular bin of the correlation.  E.g. to get 100 pairs from the third</span>
<span class="sd">        bin of a `Corr2` instance, corr, you could write::</span>

<span class="sd">            &gt;&gt;&gt; min_sep = corr.left_edges[2]   # third bin has i=2</span>
<span class="sd">            &gt;&gt;&gt; max_sep = corr.right_edges[2]</span>
<span class="sd">            &gt;&gt;&gt; i1, i2, sep = corr.sample_pairs(100, cat1, cat2, min_sep, max_sep)</span>

<span class="sd">        The min_sep and max_sep should use the same units as were defined when constructing</span>
<span class="sd">        the corr instance.</span>

<span class="sd">        The selection process will also use the same bin_slop as specified (either explicitly or</span>
<span class="sd">        implicitly) when constructing the corr instance.  This means that some of the pairs may</span>
<span class="sd">        have actual separations slightly outside of the specified range.  If you want a selection</span>
<span class="sd">        using an exact range without any slop, you should construct a new Correlation instance</span>
<span class="sd">        with bin_slop=0, and call sample_pairs with that.</span>

<span class="sd">        The returned separations will likewise correspond to the separation of the cells in the</span>
<span class="sd">        tree that TreeCorr used to place the pairs into the given bin.  Therefore, if these cells</span>
<span class="sd">        were not leaf cells, then they will not typically be equal to the real separations for the</span>
<span class="sd">        given metric.  If you care about the exact separations for each pair, you should either</span>
<span class="sd">        call sample_pairs from a Correlation instance with brute=True or recalculate the</span>
<span class="sd">        distances yourself from the original data.</span>

<span class="sd">        Also, note that min_sep and max_sep may be arbitrary.  There is no requirement that they</span>
<span class="sd">        be edges of one of the standard bins for this correlation function.  There is also no</span>
<span class="sd">        requirement that this correlation instance has already accumulated pairs via a call</span>
<span class="sd">        to process with these catalogs.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            n (int):            How many samples to return.</span>
<span class="sd">            cat1 (Catalog):     The catalog from which to sample the first object of each pair.</span>
<span class="sd">            cat2 (Catalog):     The catalog from which to sample the second object of each pair.</span>
<span class="sd">                                (This may be the same as cat1.)</span>
<span class="sd">            min_sep (float):    The minimum separation for the returned pairs (modulo some slop</span>
<span class="sd">                                allowed by the bin_slop parameter). (Note: keyword name is required</span>
<span class="sd">                                for this parameter: min_sep=min_sep)</span>
<span class="sd">            max_sep (float):    The maximum separation for the returned pairs (modulo some slop</span>
<span class="sd">                                allowed by the bin_slop parameter). (Note: keyword name is required</span>
<span class="sd">                                for this parameter: max_sep=max_sep)</span>
<span class="sd">            metric (str):       Which metric to use.  See `Metrics` for details.  (default:</span>
<span class="sd">                                self.metric, or &#39;Euclidean&#39; if not set yet)</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple containing</span>

<span class="sd">                - i1 (array): indices of objects from cat1</span>
<span class="sd">                - i2 (array): indices of objects from cat2</span>
<span class="sd">                - sep (array): separations of the pairs of objects (i1,i2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">metric</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">metric</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;metric&#39;</span><span class="p">,</span> <span class="s1">&#39;Euclidean&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_set_metric</span><span class="p">(</span><span class="n">metric</span><span class="p">,</span> <span class="n">cat1</span><span class="o">.</span><span class="n">coords</span><span class="p">,</span> <span class="n">cat2</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>

        <span class="n">f1</span> <span class="o">=</span> <span class="n">cat1</span><span class="o">.</span><span class="n">field</span>
        <span class="n">f2</span> <span class="o">=</span> <span class="n">cat2</span><span class="o">.</span><span class="n">field</span>

        <span class="k">if</span> <span class="n">f1</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">f1</span><span class="o">.</span><span class="n">_coords</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coords</span><span class="p">:</span>
            <span class="c1"># I don&#39;t really know if it&#39;s possible to get the coords out of sync,</span>
            <span class="c1"># so the 2nd check might be superfluous.</span>
            <span class="c1"># The first one though is definitely possible, so we need to check that.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;In sample_pairs, making default field for cat1&quot;</span><span class="p">)</span>
            <span class="n">min_size</span><span class="p">,</span> <span class="n">max_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_minmax_size</span><span class="p">()</span>
            <span class="n">f1</span> <span class="o">=</span> <span class="n">cat1</span><span class="o">.</span><span class="n">getNField</span><span class="p">(</span><span class="n">min_size</span><span class="o">=</span><span class="n">min_size</span><span class="p">,</span> <span class="n">max_size</span><span class="o">=</span><span class="n">max_size</span><span class="p">,</span>
                                <span class="n">split_method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">split_method</span><span class="p">,</span>
                                <span class="n">brute</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">brute</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">brute</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span>
                                <span class="n">min_top</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">min_top</span><span class="p">,</span> <span class="n">max_top</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_top</span><span class="p">,</span>
                                <span class="n">coords</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">f2</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">f2</span><span class="o">.</span><span class="n">_coords</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coords</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;In sample_pairs, making default field for cat2&quot;</span><span class="p">)</span>
            <span class="n">min_size</span><span class="p">,</span> <span class="n">max_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_minmax_size</span><span class="p">()</span>
            <span class="n">f2</span> <span class="o">=</span> <span class="n">cat2</span><span class="o">.</span><span class="n">getNField</span><span class="p">(</span><span class="n">min_size</span><span class="o">=</span><span class="n">min_size</span><span class="p">,</span> <span class="n">max_size</span><span class="o">=</span><span class="n">max_size</span><span class="p">,</span>
                                <span class="n">split_method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">split_method</span><span class="p">,</span>
                                <span class="n">brute</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">brute</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">brute</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span>
                                <span class="n">min_top</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">min_top</span><span class="p">,</span> <span class="n">max_top</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_top</span><span class="p">,</span>
                                <span class="n">coords</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>

        <span class="c1"># Apply units to min_sep, max_sep:</span>
        <span class="n">min_sep</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sep_units</span>
        <span class="n">max_sep</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sep_units</span>

        <span class="n">i1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">i2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">sep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">seed</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rng</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">*</span> <span class="mi">2</span><span class="o">**</span><span class="mi">63</span><span class="p">)</span>
        <span class="n">ntot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr</span><span class="o">.</span><span class="n">samplePairs</span><span class="p">(</span><span class="n">f1</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">f2</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">min_sep</span><span class="p">,</span> <span class="n">max_sep</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">_metric</span><span class="p">,</span> <span class="n">seed</span><span class="p">,</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">,</span> <span class="n">sep</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ntot</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">ntot</span>
            <span class="n">i1</span> <span class="o">=</span> <span class="n">i1</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span>
            <span class="n">i2</span> <span class="o">=</span> <span class="n">i2</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span>
            <span class="n">sep</span> <span class="o">=</span> <span class="n">sep</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span>
        <span class="c1"># Convert back to nominal units</span>
        <span class="n">sep</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sep_units</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Sampled </span><span class="si">%d</span><span class="s2"> pairs out of a total of </span><span class="si">%d</span><span class="s2">.&quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">ntot</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">,</span> <span class="n">sep</span></div>

    <span class="c1"># Some helper functions that are relevant for doing the covariance stuff below.</span>
    <span class="c1"># Note: the word &quot;pairs&quot; in many of these is appropriate for 2pt, but in the 3pt case</span>
    <span class="c1"># (cf. corr3.py), these actually refer to triples (i,j,k).</span>

    <span class="k">def</span> <span class="nf">_get_npatch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npatch1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_calculate_xi_from_pairs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pairs</span><span class="p">):</span>
        <span class="c1"># Compute the xi data vector for the given list of pairs.</span>
        <span class="c1"># pairs is input as a list of (i,j) values.</span>

        <span class="c1"># This is the normal calculation.  It needs to be overridden when there are randoms.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sum</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="n">ij</span><span class="p">]</span> <span class="k">for</span> <span class="n">ij</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_finalize</span><span class="p">()</span>

    <span class="c1">#########################################################################################</span>
    <span class="c1">#                                                                                       #</span>
    <span class="c1"># Important note for the following two functions.                                       #</span>
    <span class="c1"># These used to have lines like this:   `                                               #</span>
    <span class="c1">#                                                                                       #</span>
    <span class="c1">#     return [ [(j,k) for j,k in self.results.keys() if j!=i and k!=i]                  #</span>
    <span class="c1">#               for i in range(self.npatch1) ]                                          #</span>
    <span class="c1">#                                                                                       #</span>
    <span class="c1"># This double list comprehension ends up with a list of lists that takes O(npatch^3)    #</span>
    <span class="c1"># memory, which for moderately large npatch values (say 500) can be multip[le GBytes.   #</span>
    <span class="c1">#                                                                                       #</span>
    <span class="c1"># The straightforward solution was to change this to using generators:                  #</span>
    <span class="c1">#                                                                                       #</span>
    <span class="c1">#     return [ ((j,k) for j,k in self.results.keys() if j!=i and k!=i)                  #</span>
    <span class="c1">#               for i in range(self.npatch1) ]                                          #</span>
    <span class="c1">#                                                                                       #</span>
    <span class="c1"># But this doesn&#39;t work with the MPI covariance calculation, since generators aren&#39;t    #</span>
    <span class="c1"># picklable.  So the iterator classes below hold off making the generator until the     #</span>
    <span class="c1"># iteration is actually started, which keeps them picklable.                            #</span>
    <span class="c1">#                                                                                       #</span>
    <span class="c1">#########################################################################################</span>

    <span class="k">class</span> <span class="nc">PairIterator</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Iterator</span><span class="p">):</span>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">results</span><span class="p">,</span> <span class="n">npatch1</span><span class="p">,</span> <span class="n">npatch2</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">ok</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">results</span> <span class="o">=</span> <span class="n">results</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">npatch1</span> <span class="o">=</span> <span class="n">npatch1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">npatch2</span> <span class="o">=</span> <span class="n">npatch2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">index</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ok</span> <span class="o">=</span> <span class="n">ok</span>

        <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gen</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">make_gen</span><span class="p">())</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="k">def</span> <span class="fm">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gen</span><span class="p">)</span>

    <span class="k">class</span> <span class="nc">JackknifePairIterator</span><span class="p">(</span><span class="n">PairIterator</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">make_gen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># k=0 here</span>
                <span class="k">return</span> <span class="p">((</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">j</span><span class="o">!=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch1</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># j=0 here</span>
                <span class="k">return</span> <span class="p">((</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span><span class="o">!=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># For each i:</span>
                <span class="c1">#    Select all pairs where neither is i.</span>
                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch1</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch2</span>
                <span class="k">return</span> <span class="p">((</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">j</span><span class="o">!=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="ow">and</span> <span class="n">k</span><span class="o">!=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_jackknife_pairs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">np</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch1</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch1</span> <span class="o">!=</span> <span class="mi">1</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch2</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">JackknifePairIterator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch2</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="p">)]</span>

    <span class="k">class</span> <span class="nc">SamplePairIterator</span><span class="p">(</span><span class="n">PairIterator</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">make_gen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># k=0 here.</span>
                <span class="k">return</span> <span class="p">((</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">j</span><span class="o">==</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch1</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># j=0 here.</span>
                <span class="k">return</span> <span class="p">((</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span><span class="o">==</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch1</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch2</span>
                <span class="c1"># Note: It&#39;s not obvious to me a priori which of these should be the right choice.</span>
                <span class="c1">#       Empirically, they both underestimate the variance, but the second one</span>
                <span class="c1">#       does so less on the tests I have in test_patch.py.  So that&#39;s the one I&#39;m</span>
                <span class="c1">#       using.</span>
                <span class="c1"># For each i:</span>
                <span class="c1">#    Select all pairs where either is i.</span>
                <span class="c1">#return ((j,k) for j,k in self.results.keys() if j==self.index or k==self.index)</span>
                <span class="c1">#</span>
                <span class="c1"># For each i:</span>
                <span class="c1">#    Select all pairs where first is i.</span>
                <span class="k">return</span> <span class="p">((</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">j</span><span class="o">==</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_sample_pairs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">np</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch1</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch1</span> <span class="o">!=</span> <span class="mi">1</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch2</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SamplePairIterator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch2</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="p">)]</span>

    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">_ok</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># It&#39;s much faster to make the pair lists for bootstrap iterators if we keep track of</span>
        <span class="c1"># which (i,j) pairs are in the results dict using an &quot;ok&quot; matrix for quick access.</span>
        <span class="n">ok</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">npatch1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">:</span>
            <span class="n">ok</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">ok</span>

    <span class="k">class</span> <span class="nc">MarkedPairIterator</span><span class="p">(</span><span class="n">PairIterator</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">make_gen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ok</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch1</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ok</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch1</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch2</span>
                <span class="c1"># Select all pairs where first point is in index (repeating i as appropriate)</span>
                <span class="k">return</span> <span class="p">(</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npatch2</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ok</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_marked_pairs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">MarkedPairIterator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch2</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ok</span><span class="p">)</span>

    <span class="k">class</span> <span class="nc">BootstrapPairIterator</span><span class="p">(</span><span class="n">PairIterator</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">make_gen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ok</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch1</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ok</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch1</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch2</span>
                <span class="c1"># Include all represented auto-correlations once, repeating as appropriate.</span>
                <span class="c1"># This needs to be done separately from the below step to avoid extra pairs (i,i)</span>
                <span class="c1"># that you would get by looping i in index and j in index for cases where i=j at</span>
                <span class="c1"># different places in the index list.  E.g. if i=3 shows up 3 times in index, then</span>
                <span class="c1"># the naive way would get 9 instance of (3,3), whereas we only want 3 instances.</span>
                <span class="n">ret1</span> <span class="o">=</span> <span class="p">(</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ok</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="p">)</span>

                <span class="c1"># And all other pairs that aren&#39;t really auto-correlations.</span>
                <span class="c1"># These can happen at their natural multiplicity from i and j loops.</span>
                <span class="c1"># Note: This is way faster with the precomputed ok matrix.</span>
                <span class="c1"># Like 0.005 seconds per call rather than 1.2 seconds for 128 patches!</span>
                <span class="n">ret2</span> <span class="o">=</span> <span class="p">(</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ok</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="ow">and</span> <span class="n">i</span><span class="o">!=</span><span class="n">j</span> <span class="p">)</span>

                <span class="k">return</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="n">ret1</span><span class="p">,</span> <span class="n">ret2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_bootstrap_pairs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">BootstrapPairIterator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch2</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ok</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_write_params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">make_minimal_config</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">,</span> <span class="n">Corr2</span><span class="o">.</span><span class="n">_valid_params</span><span class="p">)</span>
        <span class="c1"># Add in a couple other things we want to preserve that aren&#39;t construction kwargs.</span>
        <span class="n">params</span><span class="p">[</span><span class="s1">&#39;coords&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span>
        <span class="n">params</span><span class="p">[</span><span class="s1">&#39;metric&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metric</span>
        <span class="n">params</span><span class="p">[</span><span class="s1">&#39;corr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_letters</span>
        <span class="k">return</span> <span class="n">params</span>

    <span class="k">def</span> <span class="nf">_write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">writer</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">write_patch_results</span><span class="p">,</span> <span class="n">write_cov</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">zero_tot</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="n">write_patch_results</span> <span class="ow">or</span> <span class="n">write_cov</span><span class="p">):</span>
            <span class="c1"># HDF doesn&#39;t work right with multiple groups unless they all have non-empty names.</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;main&#39;</span>
        <span class="c1"># These helper properties define what to write for each class.</span>
        <span class="n">col_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write_col_names</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write_data</span>
        <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write_params</span>

        <span class="k">if</span> <span class="n">write_patch_results</span><span class="p">:</span>
            <span class="c1"># Note: Only include npatch1, npatch2 in serialization if we are also serializing</span>
            <span class="c1"># results.  Otherwise, the corr that is read in will behave oddly.</span>
            <span class="n">params</span><span class="p">[</span><span class="s1">&#39;npatch1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch1</span>
            <span class="n">params</span><span class="p">[</span><span class="s1">&#39;npatch2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">npatch2</span>
            <span class="n">params</span><span class="p">[</span><span class="s1">&#39;num_rows&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rnom</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
            <span class="n">num_patch_pairs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">zero_tot</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">corr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">corr</span><span class="o">.</span><span class="n">_nonzero</span><span class="p">:</span>
                        <span class="n">zp_name</span> <span class="o">=</span> <span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;_zp_</span><span class="si">%d</span><span class="s1">&#39;</span><span class="o">%</span><span class="n">i</span>
                        <span class="n">params</span><span class="p">[</span><span class="n">zp_name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">((</span><span class="n">key</span><span class="p">,</span> <span class="n">corr</span><span class="o">.</span><span class="n">tot</span><span class="p">))</span>
                        <span class="n">num_patch_pairs</span> <span class="o">-=</span> <span class="mi">1</span>
                        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">params</span><span class="p">[</span><span class="s1">&#39;num_zero_patch&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">params</span><span class="p">[</span><span class="s1">&#39;num_patch_pairs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">num_patch_pairs</span>
        <span class="k">if</span> <span class="n">write_cov</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s1">&#39;cov_shape&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov</span><span class="o">.</span><span class="n">shape</span>

        <span class="n">writer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">col_names</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">write_patch_results</span><span class="p">:</span>
            <span class="n">writer</span><span class="o">.</span><span class="n">set_precision</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">corr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">zero_tot</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">corr</span><span class="o">.</span><span class="n">_nonzero</span><span class="p">:</span> <span class="k">continue</span>
                <span class="n">col_names</span> <span class="o">=</span> <span class="n">corr</span><span class="o">.</span><span class="n">_write_col_names</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">corr</span><span class="o">.</span><span class="n">_write_data</span>
                <span class="n">params</span> <span class="o">=</span> <span class="n">corr</span><span class="o">.</span><span class="n">_write_params</span>
                <span class="n">params</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="n">pp_name</span> <span class="o">=</span> <span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;_pp_</span><span class="si">%d</span><span class="s1">&#39;</span><span class="o">%</span><span class="n">i</span>
                <span class="n">writer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">col_names</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="n">pp_name</span><span class="p">)</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">assert</span> <span class="n">i</span> <span class="o">==</span> <span class="n">num_patch_pairs</span>
        <span class="k">if</span> <span class="n">write_cov</span><span class="p">:</span>
            <span class="n">writer</span><span class="o">.</span><span class="n">write_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cov</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="s1">&#39;cov&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reader</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;main&#39;</span> <span class="k">if</span> <span class="s1">&#39;main&#39;</span> <span class="ow">in</span> <span class="n">reader</span> <span class="ow">and</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">name</span>
        <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">read_params</span><span class="p">(</span><span class="n">ext</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="n">num_rows</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;num_rows&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">num_patch_pairs</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;num_patch_pairs&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">num_zero_patch</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;num_zero_patch&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">cov_shape</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;cov_shape&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;main&#39;</span> <span class="k">if</span> <span class="n">num_patch_pairs</span> <span class="ow">and</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">name</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">read_data</span><span class="p">(</span><span class="n">max_rows</span><span class="o">=</span><span class="n">num_rows</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>

        <span class="c1"># This helper function defines how to set the attributes for each class</span>
        <span class="c1"># based on what was read in.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_read_from_data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">results</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_zero_patch</span><span class="p">):</span>
            <span class="n">zp_name</span> <span class="o">=</span> <span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;_zp_</span><span class="si">%d</span><span class="s1">&#39;</span><span class="o">%</span><span class="n">i</span>
            <span class="n">key</span><span class="p">,</span> <span class="n">tot</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="n">zp_name</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zero_copy</span><span class="p">(</span><span class="n">tot</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_patch_pairs</span><span class="p">):</span>
            <span class="n">pp_name</span> <span class="o">=</span> <span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;_pp_</span><span class="si">%d</span><span class="s1">&#39;</span><span class="o">%</span><span class="n">i</span>
            <span class="n">corr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">params</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">read_params</span><span class="p">(</span><span class="n">ext</span><span class="o">=</span><span class="n">pp_name</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">read_data</span><span class="p">(</span><span class="n">max_rows</span><span class="o">=</span><span class="n">num_rows</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="n">pp_name</span><span class="p">)</span>
            <span class="n">corr</span><span class="o">.</span><span class="n">_read_from_data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
            <span class="n">key</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">corr</span>
        <span class="k">if</span> <span class="n">cov_shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cov_shape</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">cov_shape</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">cov_shape</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cov</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">read_array</span><span class="p">(</span><span class="n">cov_shape</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="s1">&#39;cov&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_read_from_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">logr</span><span class="o">.</span><span class="n">shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meanr</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;meanr&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meanlogr</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;meanlogr&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;weight&#39;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
            <span class="c1"># NN calls this DD rather than weight.  Let that class handle it.</span>
            <span class="c1"># But here, don&#39;t error if weight is missing.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">weight</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">npairs</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;npairs&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coords</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;coords&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metric</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;metric&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">npatch1</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;npatch1&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">npatch2</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;npatch2&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<div class="viewcode-block" id="Corr2.read"><a class="viewcode-back" href="../../correlation2.html#treecorr.Corr2.read">[docs]</a>    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_name</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">file_type</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read in values from a file.</span>

<span class="sd">        This should be a file that was written by TreeCorr, preferably a FITS or HDF5 file, so</span>
<span class="sd">        there is no loss of information.</span>

<span class="sd">        .. warning::</span>

<span class="sd">            The current object should be constructed with the same configuration parameters as</span>
<span class="sd">            the one being read.  e.g. the same min_sep, max_sep, etc.  This is not checked by</span>
<span class="sd">            the read function.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            file_name (str):    The name of the file to read in.</span>
<span class="sd">            file_type (str):    The type of file (&#39;ASCII&#39; or &#39;FITS&#39;).  (default: determine the type</span>
<span class="sd">                                automatically from the extension of file_name.)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Reading </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_letters</span><span class="si">}</span><span class="s1"> correlations from %s&#39;</span><span class="p">,</span><span class="n">file_name</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">make_reader</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="n">file_type</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">)</span> <span class="k">as</span> <span class="n">reader</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_read</span><span class="p">(</span><span class="n">reader</span><span class="p">)</span></div>

<div class="viewcode-block" id="Corr2.from_file"><a class="viewcode-back" href="../../correlation2.html#treecorr.Corr2.from_file">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_file</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">file_name</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">file_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a new instance from an output file.</span>

<span class="sd">        This should be a file that was written by TreeCorr.</span>

<span class="sd">        .. note::</span>

<span class="sd">            This classmethod may be called either using the base class or the class type that</span>
<span class="sd">            wrote the file.  E.g. if the file was written by `GGCorrelation`, then either</span>
<span class="sd">            of the following would work and be equivalent:</span>

<span class="sd">                &gt;&gt;&gt; gg = treecorr.GGCorrelation.from_file(file_name)</span>
<span class="sd">                &gt;&gt;&gt; gg = treecorr.Corr2.from_file(file_name)</span>

<span class="sd">        Parameters:</span>
<span class="sd">            file_name (str):    The name of the file to read in.</span>
<span class="sd">            file_type (str):    The type of file (&#39;ASCII&#39;, &#39;FITS&#39;, or &#39;HDF&#39;).  (default: determine</span>
<span class="sd">                                the type automatically from the extension of file_name.)</span>
<span class="sd">            logger (Logger):    If desired, a logger object to use for logging. (default: None)</span>
<span class="sd">            rng (RandomState):  If desired, a numpy.random.RandomState instance to use for bootstrap</span>
<span class="sd">                                random number generation. (default: None)</span>

<span class="sd">        Returns:</span>
<span class="sd">            A Correlation object, constructed from the information in the file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">cls</span> <span class="ow">is</span> <span class="n">Corr2</span><span class="p">:</span>
            <span class="c1"># Then need to figure out what class to make first.</span>
            <span class="k">with</span> <span class="n">make_reader</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="n">file_type</span><span class="p">,</span> <span class="n">logger</span><span class="p">)</span> <span class="k">as</span> <span class="n">reader</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;main&#39;</span> <span class="k">if</span> <span class="s1">&#39;main&#39;</span> <span class="ow">in</span> <span class="n">reader</span> <span class="k">else</span> <span class="kc">None</span>
                <span class="n">params</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">read_params</span><span class="p">(</span><span class="n">ext</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
                <span class="n">letters</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;corr&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">letters</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Corr2</span><span class="o">.</span><span class="n">_lookup_dict</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> does not seem to be a valid treecorr output file.&quot;</span><span class="o">%</span><span class="n">file_name</span><span class="p">)</span>
                <span class="bp">cls</span> <span class="o">=</span> <span class="n">Corr2</span><span class="o">.</span><span class="n">_lookup_dict</span><span class="p">[</span><span class="n">letters</span><span class="p">]</span>
                <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="n">file_type</span><span class="o">=</span><span class="n">file_type</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="n">rng</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">logger</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Building </span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="n">_cls</span><span class="si">}</span><span class="s1"> from %s&#39;</span><span class="p">,</span> <span class="n">file_name</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">make_reader</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="n">file_type</span><span class="p">,</span> <span class="n">logger</span><span class="p">)</span> <span class="k">as</span> <span class="n">reader</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;main&#39;</span> <span class="k">if</span> <span class="s1">&#39;main&#39;</span> <span class="ow">in</span> <span class="n">reader</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="n">params</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">read_params</span><span class="p">(</span><span class="n">ext</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
            <span class="n">letters</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;corr&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">letters</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Corr2</span><span class="o">.</span><span class="n">_lookup_dict</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> does not seem to be a valid treecorr output file.&quot;</span><span class="o">%</span><span class="n">file_name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;corr&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_letters</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s2">&quot;Trying to read a </span><span class="si">%s</span><span class="s2">Correlation output file with </span><span class="si">%s</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span>
                                <span class="n">params</span><span class="p">[</span><span class="s1">&#39;corr&#39;</span><span class="p">],</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="n">make_minimal_config</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">Corr2</span><span class="o">.</span><span class="n">_valid_params</span><span class="p">)</span>
            <span class="n">corr</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="n">rng</span><span class="p">)</span>
            <span class="n">corr</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Reading </span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="n">_letters</span><span class="si">}</span><span class="s1"> correlations from %s&#39;</span><span class="p">,</span> <span class="n">file_name</span><span class="p">)</span>
            <span class="n">corr</span><span class="o">.</span><span class="n">_read</span><span class="p">(</span><span class="n">reader</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">corr</span></div></div>


<div class="viewcode-block" id="estimate_multi_cov"><a class="viewcode-back" href="../../correlation2.html#treecorr.estimate_multi_cov">[docs]</a><span class="k">def</span> <span class="nf">estimate_multi_cov</span><span class="p">(</span><span class="n">corrs</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Estimate the covariance matrix of multiple statistics.</span>

<span class="sd">    This is like the method `Corr2.estimate_cov`, except that it will acoommodate</span>
<span class="sd">    multiple statistics from a list ``corrs`` of `Corr2` objects.</span>

<span class="sd">    Options for ``method`` include:</span>

<span class="sd">        - &#39;shot&#39; = The variance based on &quot;shot noise&quot; only.  This includes the Poisson</span>
<span class="sd">          counts of points for N statistics, shape noise for G statistics, and the observed</span>
<span class="sd">          scatter in the values for K statistics.  In this case, the returned value will only</span>
<span class="sd">          be the diagonal.  Use np.diagonal(cov) if you actually want a full matrix from this.</span>
<span class="sd">        - &#39;jackknife&#39; = A jackknife estimate of the covariance matrix based on the scatter</span>
<span class="sd">          in the measurement when excluding one patch at a time.</span>
<span class="sd">        - &#39;sample&#39; = An estimate based on the sample covariance of a set of samples,</span>
<span class="sd">          taken as the patches of the input catalog.</span>
<span class="sd">        - &#39;bootstrap&#39; = A bootstrap covariance estimate. It selects patches at random with</span>
<span class="sd">          replacement and then generates the statistic using all the auto-correlations at</span>
<span class="sd">          their selected repetition plus all the cross terms that aren&#39;t actually auto terms.</span>
<span class="sd">        - &#39;marked_bootstrap&#39; = An estimate based on a marked-point bootstrap resampling of the</span>
<span class="sd">          patches.  Similar to bootstrap, but only samples the patches of the first catalog and</span>
<span class="sd">          uses all patches from the second catalog that correspond to each patch selection of</span>
<span class="sd">          the first catalog.  Based on the algorithm presented in Loh (2008).</span>
<span class="sd">          cf. https://ui.adsabs.harvard.edu/abs/2008ApJ...681..726L/</span>

<span class="sd">    Both &#39;bootstrap&#39; and &#39;marked_bootstrap&#39; use the num_bootstrap parameter, which can be set on</span>
<span class="sd">    construction.</span>

<span class="sd">    For example, to find the combined covariance matrix for an NG tangential shear statistc,</span>
<span class="sd">    along with the GG xi+ and xi- from the same area, using jackknife covariance estimation,</span>
<span class="sd">    you would write::</span>

<span class="sd">        &gt;&gt;&gt; cov = treecorr.estimate_multi_cov([ng,gg], method=&#39;jackknife&#39;)</span>

<span class="sd">    In all cases, the relevant processing needs to already have been completed and finalized.</span>
<span class="sd">    And for all methods other than &#39;shot&#39;, the processing should have involved an appropriate</span>
<span class="sd">    number of patches -- preferably more patches than the length of the vector for your</span>
<span class="sd">    statistic, although this is not checked.</span>

<span class="sd">    The default order of the covariance matrix is to simply concatenate the data vectors</span>
<span class="sd">    for each corr in the list ``corrs``.  However, if you want to do something more complicated,</span>
<span class="sd">    you may provide an arbitrary function, ``func``, which should act on the list of correlations.</span>
<span class="sd">    For instance, if you have several `GGCorrelation` objects and would like to order the</span>
<span class="sd">    covariance such that all xi+ results come first, and then all xi- results, you could use</span>

<span class="sd">        &gt;&gt;&gt; func = lambda corrs: np.concatenate([c.xip for c in corrs] + [c.xim for c in corrs])</span>

<span class="sd">    Or if you want to compute the covariance matrix of some derived quantity like the ratio</span>
<span class="sd">    of two correlations, you could use</span>

<span class="sd">        &gt;&gt;&gt; func = lambda corrs: corrs[0].xi / corrs[1].xi</span>

<span class="sd">    This function can be parallelized by passing the comm argument as an mpi4py communicator to</span>
<span class="sd">    parallelize using that.  For MPI, all processes should have the same inputs.</span>
<span class="sd">    If method == &quot;shot&quot; then parallelization has no effect.</span>

<span class="sd">    The return value from this func should be a single numpy array. (This is not directly</span>
<span class="sd">    checked, but you&#39;ll probably get some kind of exception if it doesn&#39;t behave as expected.)</span>

<span class="sd">    .. note::</span>

<span class="sd">        The optional ``func`` parameter is not valid in conjunction with ``method=&#39;shot&#39;``.</span>
<span class="sd">        It only works for the methods that are based on patch combinations.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        corrs (list):       A list of `Corr2` instances.</span>
<span class="sd">        method (str):       Which method to use to estimate the covariance matrix.</span>
<span class="sd">        func (function):    A unary function that takes the list ``corrs`` and returns the</span>
<span class="sd">                            desired full data vector. [default: None, which is equivalent to</span>
<span class="sd">                            ``lambda corrs: np.concatenate([c.getStat() for c in corrs])``]</span>
<span class="sd">        comm (mpi comm)     If not None, run under MPI</span>

<span class="sd">    Returns:</span>
<span class="sd">        A numpy array with the estimated covariance matrix.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;shot&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;func is invalid with method=&#39;shot&#39;&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_cov_shot</span><span class="p">(</span><span class="n">corrs</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;jackknife&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_cov_jackknife</span><span class="p">(</span><span class="n">corrs</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="n">comm</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;bootstrap&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_cov_bootstrap</span><span class="p">(</span><span class="n">corrs</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="n">comm</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;marked_bootstrap&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_cov_marked</span><span class="p">(</span><span class="n">corrs</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="n">comm</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;sample&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_cov_sample</span><span class="p">(</span><span class="n">corrs</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="n">comm</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid method: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="o">%</span><span class="n">method</span><span class="p">)</span></div>

<div class="viewcode-block" id="build_multi_cov_design_matrix"><a class="viewcode-back" href="../../correlation2.html#treecorr.build_multi_cov_design_matrix">[docs]</a><span class="k">def</span> <span class="nf">build_multi_cov_design_matrix</span><span class="p">(</span><span class="n">corrs</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Build the design matrix that is used for estimating the covariance matrix.</span>

<span class="sd">    The design matrix for patch-based covariance estimates is a matrix where each row</span>
<span class="sd">    corresponds to a different estimate of the data vector, :math:`\\xi_i` (or</span>
<span class="sd">    :math:`f(\\xi_i)` if using the optional ``func`` parameter).</span>

<span class="sd">    The different of rows in the matrix for each valid ``method`` are:</span>

<span class="sd">        - &#39;shot&#39;: This method is not valid here.</span>
<span class="sd">        - &#39;jackknife&#39;: The data vector when excluding a single patch.</span>
<span class="sd">        - &#39;sample&#39;: The data vector using only a single patch for the first catalog.</span>
<span class="sd">        - &#39;bootstrap&#39;: The data vector for a random resampling of the patches keeping the</span>
<span class="sd">          sample total number, but allowing some to repeat.  Cross terms from repeated patches</span>
<span class="sd">          are excluded (since they are really auto terms).</span>
<span class="sd">        - &#39;marked_bootstrap&#39;: The data vector for a random resampling of patches in the first</span>
<span class="sd">          catalog, using all patches for the second catalog.  Based on the algorithm in Loh(2008).</span>

<span class="sd">    See `estimate_multi_cov` for more details.</span>

<span class="sd">    The return value includes both the design matrix and a vector of weights (the total weight</span>
<span class="sd">    array in the computed correlation functions).  The weights are used for the sample method</span>
<span class="sd">    when estimating the covariance matrix.  The other methods ignore them, but they are provided</span>
<span class="sd">    here in case they are useful.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        corrs (list):       A list of `Corr2` instances.</span>
<span class="sd">        method (str):       Which method to use to estimate the covariance matrix.</span>
<span class="sd">        func (function):    A unary function that takes the list ``corrs`` and returns the</span>
<span class="sd">                            desired full data vector. [default: None, which is equivalent to</span>
<span class="sd">                            ``lambda corrs: np.concatenate([c.getStat() for c in corrs])``]</span>
<span class="sd">        comm (mpi comm)     If not None, run under MPI</span>

<span class="sd">    Returns:</span>
<span class="sd">        (A, w), numpy arrays with the design matrix and weights respectively.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;shot&#39;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;There is no design matrix for method=&#39;shot&#39;&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;jackknife&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_design_jackknife</span><span class="p">(</span><span class="n">corrs</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="n">comm</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;bootstrap&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_design_bootstrap</span><span class="p">(</span><span class="n">corrs</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="n">comm</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;marked_bootstrap&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_design_marked</span><span class="p">(</span><span class="n">corrs</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="n">comm</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;sample&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_design_sample</span><span class="p">(</span><span class="n">corrs</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="n">comm</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid method: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="o">%</span><span class="n">method</span><span class="p">)</span></div>

<span class="k">def</span> <span class="nf">_make_cov_design_matrix_core</span><span class="p">(</span><span class="n">corrs</span><span class="p">,</span> <span class="n">plist</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="c1"># plist has the pairs to use for each row in the design matrix for each correlation fn.</span>
    <span class="c1"># It is a list by row, each element is a list by corr fn of tuples (i,j), being the indices</span>
    <span class="c1"># to use from the results dict.</span>
    <span class="c1"># We aggregate and finalize each correlation function based on those pairs, and then call</span>
    <span class="c1"># the function func on that list of correlation objects.  This is the data vector for</span>
    <span class="c1"># each row in the design matrix.</span>
    <span class="c1"># We also make a parallel array of the total weight in each row in case the calling routing</span>
    <span class="c1"># needs it. So far, only sample uses the returned w, but it&#39;s very little overhead to compute</span>
    <span class="c1"># it, and only a small memory overhead to build that array and return it.</span>

    <span class="c1"># Make a copy of the correlation objects, so we can overwrite things without breaking</span>
    <span class="c1"># the original.</span>
    <span class="n">corrs</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">corrs</span><span class="p">]</span>

    <span class="c1"># We can&#39;t pickle functions to send via MPI, so have to do this here.</span>
    <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">corrs</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">c</span><span class="o">.</span><span class="n">getStat</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">corrs</span><span class="p">])</span>

    <span class="c1"># Figure out the shape of the design matrix.</span>
    <span class="n">v1</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">corrs</span><span class="p">)</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">v1</span><span class="o">.</span><span class="n">dtype</span>
    <span class="n">vsize</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span>
    <span class="n">nrows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">plist</span><span class="p">)</span>

    <span class="c1"># Make the empty return arrays. They are filled with zeros</span>
    <span class="c1"># because we will sum them over processes later.</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nrows</span><span class="p">,</span><span class="n">vsize</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nrows</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">row</span><span class="p">,</span> <span class="n">pairs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">plist</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">row</span> <span class="o">%</span> <span class="n">size</span> <span class="o">!=</span> <span class="n">rank</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">cpairs</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">corrs</span><span class="p">,</span> <span class="n">pairs</span><span class="p">):</span>
            <span class="n">cpairs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">cpairs</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cpairs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># This will cause problems downstream if we let it go.</span>
                <span class="c1"># It probably indicates user error, using an inappropriate covariance estimator.</span>
                <span class="c1"># So warn about it, and then do something not too crazy.</span>
                <span class="n">c</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;WARNING: A xi for calculating the </span><span class="si">%s</span><span class="s2"> covariance has no &quot;</span><span class="o">%</span><span class="n">name</span> <span class="o">+</span>
                               <span class="s2">&quot;patch pairs.  This probably means these patch specifications &quot;</span>
                               <span class="s2">&quot;are inappropriate for these data.&quot;</span><span class="p">)</span>
                <span class="n">c</span><span class="o">.</span><span class="n">_clear</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">c</span><span class="o">.</span><span class="n">_calculate_xi_from_pairs</span><span class="p">(</span><span class="n">cpairs</span><span class="p">)</span>
        <span class="n">v</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">corrs</span><span class="p">)</span>
        <span class="n">w</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">getWeight</span><span class="p">())</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">corrs</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">v</span><span class="p">,</span><span class="n">w</span>

<span class="k">def</span> <span class="nf">_make_cov_design_matrix</span><span class="p">(</span><span class="n">corrs</span><span class="p">,</span> <span class="n">plist</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">comm</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">comm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">mpi4py.MPI</span> <span class="kn">import</span> <span class="n">IN_PLACE</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="c1"># Probably testing using MockMPI...</span>
            <span class="n">IN_PLACE</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">v</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">_make_cov_design_matrix_core</span><span class="p">(</span><span class="n">corrs</span><span class="p">,</span> <span class="n">plist</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">comm</span><span class="o">.</span><span class="n">rank</span><span class="p">,</span> <span class="n">comm</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="c1"># These two calls collects the v arrays from w arrays from all the processors,</span>
        <span class="c1"># sums them all together, and then sends them back to each processor where they</span>
        <span class="c1"># are put back in-place, overwriting the original v and w array contents.</span>
        <span class="c1"># Each process has an array which is zeros except for the rows it is responsible</span>
        <span class="c1"># for, so the sum fills in the entire array.</span>
        <span class="c1"># Using &quot;Allreduce&quot; instead of &quot;Reduce&quot; means that all processes get a copy of the</span>
        <span class="c1"># final arrays. This may or may not be needed depending on what users subsequently</span>
        <span class="c1"># do with the matrix, but is fast since this matrix isn&#39;t large.</span>
        <span class="n">comm</span><span class="o">.</span><span class="n">Allreduce</span><span class="p">(</span><span class="n">IN_PLACE</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="n">comm</span><span class="o">.</span><span class="n">Allreduce</span><span class="p">(</span><span class="n">IN_PLACE</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
    <span class="c1"># Otherwise we just use the regular version, which implicitly does the whole matrix</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">v</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">_make_cov_design_matrix_core</span><span class="p">(</span><span class="n">corrs</span><span class="p">,</span> <span class="n">plist</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span>

<span class="k">def</span> <span class="nf">_cov_shot</span><span class="p">(</span><span class="n">corrs</span><span class="p">):</span>
    <span class="c1"># Shot noise &quot;covariance&quot; is just 1/RR or var(g)/weight or var(k)/weight, etc.</span>
    <span class="c1"># Except for NN, the denominator is always corr.weight.</span>
    <span class="c1"># For NN, the denominator is set by calculateXi to be RR.weight.</span>
    <span class="c1"># The numerators are set appropriately for each kind of correlation function as _var_num</span>
    <span class="c1"># when doing finalize, or for NN also in calculateXi.</span>
    <span class="c1"># We return it as a covariance matrix for consistency with the other cov functions,</span>
    <span class="c1"># but the off diagonal terms are all zero.</span>
    <span class="n">vlist</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">corrs</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">getWeight</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">mask1</span> <span class="o">=</span> <span class="n">v</span> <span class="o">!=</span> <span class="mi">0</span>
        <span class="c1"># Note: if w=0 anywhere, leave v=0 there, rather than divide by zero.</span>
        <span class="n">v</span><span class="p">[</span><span class="n">mask1</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">_var_num</span> <span class="o">/</span> <span class="n">v</span><span class="p">[</span><span class="n">mask1</span><span class="p">]</span>
        <span class="n">vlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">vlist</span><span class="p">)</span>  <span class="c1"># Return as just the diagonal</span>

<span class="k">def</span> <span class="nf">_check_patch_nums</span><span class="p">(</span><span class="n">corrs</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
    <span class="c1"># Figure out what pairs (i,j) are possible for these correlation functions.</span>
    <span class="c1"># Check that the patches used are compatible, and return the npatch to use.</span>

    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">corrs</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">results</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Using </span><span class="si">%s</span><span class="s2"> covariance requires using patches.&quot;</span><span class="o">%</span><span class="n">name</span><span class="p">)</span>
    <span class="n">npatch</span> <span class="o">=</span> <span class="n">corrs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_get_npatch</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">corrs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">_get_npatch</span><span class="p">()</span> <span class="o">!=</span> <span class="n">npatch</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;All correlations must use the same number of patches&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">npatch</span>

<span class="k">def</span> <span class="nf">_design_jackknife</span><span class="p">(</span><span class="n">corrs</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">comm</span><span class="p">):</span>
    <span class="n">npatch</span> <span class="o">=</span> <span class="n">_check_patch_nums</span><span class="p">(</span><span class="n">corrs</span><span class="p">,</span> <span class="s1">&#39;jackknife&#39;</span><span class="p">)</span>
    <span class="n">plist</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">_jackknife_pairs</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">corrs</span><span class="p">]</span>
    <span class="c1"># Swap order of plist.  Right now it&#39;s a list for each corr of a list for each row.</span>
    <span class="c1"># We want a list by row with a list for each corr.</span>
    <span class="n">plist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">plist</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">_make_cov_design_matrix</span><span class="p">(</span><span class="n">corrs</span><span class="p">,</span> <span class="n">plist</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="s1">&#39;jackknife&#39;</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="n">comm</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_cov_jackknife</span><span class="p">(</span><span class="n">corrs</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">comm</span><span class="p">):</span>
    <span class="c1"># Calculate the jackknife covariance for the given statistics</span>

    <span class="c1"># The basic jackknife formula is:</span>
    <span class="c1"># C = (1-1/npatch) Sum_i (v_i - v_mean) (v_i - v_mean)^T</span>
    <span class="c1"># where v_i is the vector when excluding patch i, and v_mean is the mean of all {v_i}.</span>
    <span class="c1">#   v_i = Sum_jk!=i num_jk / Sum_jk!=i denom_jk</span>

    <span class="n">v</span><span class="p">,</span><span class="n">w</span> <span class="o">=</span> <span class="n">_design_jackknife</span><span class="p">(</span><span class="n">corrs</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">comm</span><span class="p">)</span>
    <span class="n">npatch</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">vmean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">-=</span> <span class="n">vmean</span>
    <span class="n">C</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="mf">1.</span><span class="o">/</span><span class="n">npatch</span><span class="p">)</span> <span class="o">*</span> <span class="n">v</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">C</span>

<span class="k">def</span> <span class="nf">_design_sample</span><span class="p">(</span><span class="n">corrs</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">comm</span><span class="p">):</span>
    <span class="n">npatch</span> <span class="o">=</span> <span class="n">_check_patch_nums</span><span class="p">(</span><span class="n">corrs</span><span class="p">,</span> <span class="s1">&#39;sample&#39;</span><span class="p">)</span>
    <span class="n">plist</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">_sample_pairs</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">corrs</span><span class="p">]</span>
    <span class="c1"># Swap order of plist.  Right now it&#39;s a list for each corr of a list for each row.</span>
    <span class="c1"># We want a list by row with a list for each corr.</span>
    <span class="n">plist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">plist</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">_make_cov_design_matrix</span><span class="p">(</span><span class="n">corrs</span><span class="p">,</span> <span class="n">plist</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="n">comm</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_cov_sample</span><span class="p">(</span><span class="n">corrs</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">comm</span><span class="p">):</span>
    <span class="c1"># Calculate the sample covariance.</span>

    <span class="c1"># This is kind of the converse of the jackknife.  We take each patch and use any</span>
    <span class="c1"># correlations of it with any other patch.  The sample variance of these is the estimate</span>
    <span class="c1"># of the overall variance.</span>

    <span class="c1"># C = 1/(npatch-1) Sum_i w_i (v_i - v_mean) (v_i - v_mean)^T</span>
    <span class="c1"># where v_i = Sum_j num_ij / Sum_j denom_ij</span>
    <span class="c1"># and w_i is the fraction of the total weight in each patch</span>

    <span class="n">v</span><span class="p">,</span><span class="n">w</span> <span class="o">=</span> <span class="n">_design_sample</span><span class="p">(</span><span class="n">corrs</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">comm</span><span class="p">)</span>
    <span class="n">npatch</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">w</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Cannot compute sample variance when some patches have no data.&quot;</span><span class="p">)</span>

    <span class="n">w</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>  <span class="c1"># Now w is the fractional weight for each patch</span>

    <span class="n">vmean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">-=</span> <span class="n">vmean</span>
    <span class="n">C</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">npatch</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="n">v</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">C</span>

<span class="k">def</span> <span class="nf">_design_marked</span><span class="p">(</span><span class="n">corrs</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">comm</span><span class="p">):</span>
    <span class="n">npatch</span> <span class="o">=</span> <span class="n">_check_patch_nums</span><span class="p">(</span><span class="n">corrs</span><span class="p">,</span> <span class="s1">&#39;marked_bootstrap&#39;</span><span class="p">)</span>
    <span class="n">nboot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">c</span><span class="o">.</span><span class="n">num_bootstrap</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">corrs</span><span class="p">])</span>  <span class="c1"># use the maximum if they differ.</span>

    <span class="n">plist</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nboot</span><span class="p">):</span>
        <span class="c1"># Select a random set of indices to use.  (Will have repeats.)</span>
        <span class="c1"># Note use choice rather than integers, so it is backwards compatible with the old</span>
        <span class="c1"># np.random.RandomState (which used randint rather than integers for that functionality).</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">corrs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">rng</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">npatch</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="n">npatch</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">vpairs</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">_marked_pairs</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">corrs</span><span class="p">]</span>
        <span class="n">plist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vpairs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_make_cov_design_matrix</span><span class="p">(</span><span class="n">corrs</span><span class="p">,</span> <span class="n">plist</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="s1">&#39;marked_bootstrap&#39;</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="n">comm</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_cov_marked</span><span class="p">(</span><span class="n">corrs</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">comm</span><span class="p">):</span>
    <span class="c1"># Calculate the marked-point bootstrap covariance</span>

    <span class="c1"># This is based on the article A Valid and Fast Spatial Bootstrap for Correlation Functions</span>
    <span class="c1"># by Ji Meng Loh, 2008, cf. https://ui.adsabs.harvard.edu/abs/2008ApJ...681..726L/abstract</span>

    <span class="c1"># We do a bootstrap sampling of the patches.  For each patch selected, we include</span>
    <span class="c1"># all pairs that have the sampled patch in the first position.  In the Loh prescription,</span>
    <span class="c1"># the sums of pairs with a given choice of first patch would be the marks.  Here, we</span>
    <span class="c1"># don&#39;t quite do that, since the marks would involve a ratio, so the division is biased</span>
    <span class="c1"># when somewhat noisy.  Rather, we sum the numerators and denominators of the marks</span>
    <span class="c1"># separately and divide the sums.</span>

    <span class="c1"># From the bootstrap totals, v_i, the estimated covariance matrix is</span>

    <span class="c1"># C = 1/(nboot) Sum_i (v_i - v_mean) (v_i - v_mean)^T</span>

    <span class="n">v</span><span class="p">,</span><span class="n">w</span> <span class="o">=</span> <span class="n">_design_marked</span><span class="p">(</span><span class="n">corrs</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">comm</span><span class="p">)</span>
    <span class="n">nboot</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">vmean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">-=</span> <span class="n">vmean</span>
    <span class="n">C</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">nboot</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">v</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">C</span>

<span class="k">def</span> <span class="nf">_design_bootstrap</span><span class="p">(</span><span class="n">corrs</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">comm</span><span class="p">):</span>
    <span class="n">npatch</span> <span class="o">=</span> <span class="n">_check_patch_nums</span><span class="p">(</span><span class="n">corrs</span><span class="p">,</span> <span class="s1">&#39;bootstrap&#39;</span><span class="p">)</span>
    <span class="n">nboot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">c</span><span class="o">.</span><span class="n">num_bootstrap</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">corrs</span><span class="p">])</span>  <span class="c1"># use the maximum if they differ.</span>

    <span class="n">plist</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nboot</span><span class="p">):</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">corrs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">rng</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">npatch</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="n">npatch</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">vpairs</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">_bootstrap_pairs</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">corrs</span><span class="p">]</span>
        <span class="n">plist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vpairs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_make_cov_design_matrix</span><span class="p">(</span><span class="n">corrs</span><span class="p">,</span> <span class="n">plist</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="s1">&#39;bootstrap&#39;</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="n">comm</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_cov_bootstrap</span><span class="p">(</span><span class="n">corrs</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">comm</span><span class="p">):</span>
    <span class="c1"># Calculate the 2-patch bootstrap covariance estimate.</span>

    <span class="c1"># This is a different version of the bootstrap idea.  It selects patches at random with</span>
    <span class="c1"># replacement, and then generates the statistic using all the auto-correlations at their</span>
    <span class="c1"># selected repetition plus all the cross terms, which aren&#39;t actually auto terms.</span>
    <span class="c1"># It seems to do a slightly better job than the marked-point bootstrap above from the</span>
    <span class="c1"># tests done in the test suite.  But the difference is generally pretty small.</span>

    <span class="n">v</span><span class="p">,</span><span class="n">w</span> <span class="o">=</span> <span class="n">_design_bootstrap</span><span class="p">(</span><span class="n">corrs</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">comm</span><span class="p">)</span>
    <span class="n">nboot</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">vmean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">-=</span> <span class="n">vmean</span>
    <span class="n">C</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">nboot</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">v</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">C</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019, Mike Jarvis.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>